<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spunk.Bet — Casino Games on Bitcoin</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="canonical" href="https://spunk.bet">
  <script>if (location.protocol !== 'https:' && location.hostname !== 'localhost') location.replace('https://' + location.host + location.pathname + location.search);</script>
  <meta name="description" content="Play provably fair casino games with SPUNK•BET rune on Bitcoin. Refer friends, earn 500 SPUNK•BET per referral. Top referrers win bonus rewards.">
  <meta property="og:title" content="Spunk.Bet — Casino Games on Bitcoin">
  <meta property="og:description" content="Provably fair Bitcoin casino powered by SPUNK•BET rune. Refer friends &amp; earn 500 SPUNK•BET per signup. First 100 referrers get bonus SPUNK•BET. Join now.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://spunk.bet">
  <meta property="og:image" content="https://spunk.bet/og-image.png">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@SpunkArt13">
  <meta name="twitter:creator" content="@SpunkArt13">
  <meta name="twitter:title" content="Spunk.Bet — Earn SPUNK•BET by Referring Friends">
  <meta name="twitter:description" content="Provably fair Bitcoin casino powered by SPUNK•BET rune. Refer friends, earn 500 SPUNK•BET each. First 100 referrers get bonus rewards.">
  <meta name="twitter:image" content="https://spunk.bet/og-image.png">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #0d0d0d;
      --surface: #111111;
      --surface2: #1a1a1a;
      --border: #222222;
      --text: #e4e4e7;
      --muted: #71717a;
      --accent: #ff5f1f;
      --accent-dim: #cc5500;
      --accent-glow: rgba(255, 95, 31, 0.25);
      --accent-glow2: rgba(255, 95, 31, 0.12);
      --green: #22c55e;
      --red: #ef4444;
      --yellow: #eab308;
      --gold: #f59e0b;
      --purple: #a855f7;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    /* NAV */
    nav {
      display: flex; align-items: center; justify-content: space-between;
      padding: 1rem 2rem; border-bottom: 1px solid var(--border);
      position: sticky; top: 0; z-index: 100;
      background: rgba(13,13,13,0.95); backdrop-filter: blur(12px);
    }
    .logo { font-size: 1.4rem; font-weight: 700; letter-spacing: -0.03em; cursor: pointer; }
    .logo span { color: var(--accent); }
    .nav-center { display: flex; gap: 0.25rem; }
    .nav-tab {
      padding: 0.5rem 1rem; border-radius: 8px; font-size: 0.85rem; font-weight: 500;
      color: var(--muted); cursor: pointer; border: none; background: none; transition: all 0.2s;
    }
    .nav-tab:hover { color: var(--text); }
    .nav-tab.active { color: var(--accent); background: var(--accent-glow); }
    .nav-right { display: flex; align-items: center; gap: 0.75rem; }
    .balance-display {
      background: var(--surface); border: 1px solid var(--border); border-radius: 8px;
      padding: 0.4rem 0.8rem; font-size: 0.85rem; font-weight: 600;
    }
    .balance-display span { color: var(--accent); }
    .btn {
      background: var(--accent); color: #fff; border: none; padding: 0.6rem 1.4rem;
      border-radius: 10px; font-size: 0.9rem; font-weight: 700; cursor: pointer; transition: all 0.15s;
      letter-spacing: 0.01em;
    }
    .btn:hover { opacity: 0.9; transform: translateY(-1px); }
    .btn:active { transform: scale(0.97) translateY(0); }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }
    .btn-sm { padding: 0.4rem 0.8rem; font-size: 0.8rem; }
    .btn-outline { background: transparent; border: 1px solid var(--border); color: var(--text); }
    .btn-outline:hover { border-color: var(--accent); }
    .btn-green { background: var(--green); }
    .btn-red { background: var(--red); }

    /* HAMBURGER MENU */
    .hamburger {
      display: none; background: none; border: none; cursor: pointer; padding: 0.25rem;
      flex-direction: column; gap: 4px; z-index: 110;
    }
    .hamburger span {
      display: block; width: 20px; height: 2px; background: var(--text); border-radius: 2px;
      transition: all 0.3s;
    }
    .hamburger.open span:nth-child(1) { transform: rotate(45deg) translate(4px, 4px); }
    .hamburger.open span:nth-child(2) { opacity: 0; }
    .hamburger.open span:nth-child(3) { transform: rotate(-45deg) translate(4px, -4px); }
    .mobile-menu {
      display: none; position: fixed; top: 57px; left: 0; right: 0; bottom: 0;
      background: rgba(13,13,13,0.98); backdrop-filter: blur(12px); z-index: 99;
      flex-direction: column; align-items: center; justify-content: center; gap: 0.5rem;
    }
    .mobile-menu.show { display: flex; }
    .mobile-menu button {
      background: none; border: 1px solid var(--border); color: var(--text); padding: 1rem 3rem;
      border-radius: 12px; font-size: 1.1rem; font-weight: 600; cursor: pointer;
      transition: all 0.2s; width: 260px; text-align: center;
    }
    .mobile-menu button:hover { border-color: var(--accent); color: var(--accent); }

    /* PAGES */
    .page { display: none; }
    .page.active { display: block; }

    /* HERO */
    .hero { text-align: center; padding: 3.5rem 2rem 2rem; position: relative; }
    .hero::before {
      content: ''; position: absolute; top: -40%; left: 50%; transform: translateX(-50%);
      width: 600px; height: 600px;
      background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%); pointer-events: none;
    }
    .hero h1 { font-size: clamp(2.5rem,6vw,4rem); font-weight: 800; letter-spacing: -0.04em; line-height: 1.1; margin-bottom: 1rem; }
    .hero h1 span { color: var(--accent); }
    .hero p { color: var(--muted); font-size: 1.1rem; max-width: 480px; margin: 0 auto 2rem; line-height: 1.6; }
    .hero-rune {
      display: inline-block; background: var(--accent-glow); border: 1px solid var(--accent);
      border-radius: 8px; padding: 0.3rem 0.8rem; font-size: 0.8rem; font-weight: 700;
      color: var(--accent); margin-bottom: 1rem; letter-spacing: 0.05em;
    }

    /* FAUCET */
    .faucet-banner {
      max-width: 900px; margin: 0 auto; padding: 0 2rem 1.5rem;
    }
    .faucet-card {
      background: linear-gradient(135deg, rgba(34,197,94,0.08), rgba(255,95,31,0.08));
      border: 1px solid var(--green); border-radius: 14px;
      padding: 1.25rem 1.5rem; display: flex; align-items: center; justify-content: space-between;
      gap: 1rem; flex-wrap: wrap;
    }
    .faucet-left h3 { font-size: 1rem; font-weight: 700; margin-bottom: 0.2rem; }
    .faucet-left h3 span { color: var(--green); }
    .faucet-left p { font-size: 0.8rem; color: var(--muted); line-height: 1.5; }
    .faucet-btn {
      background: var(--green); color: #fff; border: none; padding: 0.6rem 1.5rem;
      border-radius: 10px; font-size: 0.9rem; font-weight: 700; cursor: pointer;
      transition: all 0.15s; white-space: nowrap;
    }
    .faucet-btn:hover { opacity: 0.9; }
    .faucet-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    /* ORIGINALS SECTION */
    .originals-header {
      max-width: 1100px; margin: 0 auto; padding: 0 2rem 0.75rem;
      display: flex; align-items: center; gap: 0.5rem;
    }
    .originals-header h2 {
      font-size: 1rem; font-weight: 700; letter-spacing: -0.01em; color: #fff;
    }
    .originals-header .tag {
      background: rgba(255,95,31,0.12); color: var(--accent); font-size: 0.65rem;
      font-weight: 700; padding: 0.15rem 0.5rem; border-radius: 4px;
      letter-spacing: 0.04em;
    }

    /* GAME CARDS - Winna/Stake Style */
    .game-grid {
      max-width: 1100px; margin: 0 auto; padding: 0 2rem 4rem;
      display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.75rem;
    }
    .game-card {
      background: #181818; border: 1px solid #222; border-radius: 12px;
      padding: 1.5rem 1rem 2.2rem; cursor: pointer; transition: all 0.2s ease; position: relative; overflow: hidden;
      display: flex; flex-direction: column; align-items: center; text-align: center;
      min-height: 170px; justify-content: center;
    }
    .game-card:hover {
      background: #1e1e1e; border-color: #333;
      transform: translateY(-3px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }
    .game-card-icon {
      font-size: 2.8rem; margin-bottom: 0.6rem; transition: transform 0.2s ease;
    }
    .game-card:hover .game-card-icon { transform: scale(1.1); }
    .game-card h3 {
      font-size: 0.9rem; font-weight: 700; margin-bottom: 0.15rem; color: #fff;
      letter-spacing: -0.01em;
    }
    .game-card p { display: none; }
    .game-card-desc {
      display: block !important; font-size: 0.7rem !important; color: #666 !important;
      margin: 0; font-weight: 500;
    }
    .game-card-edge {
      position: absolute; bottom: 0.5rem; left: 50%; transform: translateX(-50%);
      font-size: 0.7rem; font-weight: 700; color: var(--accent);
      padding: 0.15rem 0.6rem; border-radius: 4px;
      letter-spacing: 0.02em;
      background: rgba(255,95,31,0.1);
    }

    /* GAME CONTAINER */
    .game-container {
      max-width: 680px; margin: 0 auto; padding: 2rem;
    }
    .game-back {
      color: var(--muted); font-size: 0.85rem; cursor: pointer; margin-bottom: 1rem;
      display: inline-flex; align-items: center; gap: 0.3rem; border: none; background: none;
      transition: color 0.2s;
    }
    .game-back:hover { color: var(--text); }
    .game-title { font-size: 1.75rem; font-weight: 800; margin-bottom: 0.5rem; letter-spacing: -0.02em; }
    .game-payout-badge {
      display: inline-flex; align-items: center; gap: 0.4rem;
      background: var(--surface); border: 1px solid var(--border); border-radius: 10px;
      padding: 0.4rem 0.9rem; margin-bottom: 1.5rem; font-size: 0.85rem;
    }
    .game-payout-badge .payout-label { color: var(--muted); font-weight: 500; }
    .game-payout-badge .payout-value { color: var(--green); font-weight: 800; font-size: 1rem; }

    /* BET CONTROLS */
    .bet-controls {
      background: var(--surface); border: 1px solid var(--border); border-radius: 14px;
      padding: 1.25rem; margin-bottom: 1rem;
    }
    .bet-row { display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem; }
    .bet-row:last-child { margin-bottom: 0; }
    .bet-label { font-size: 0.8rem; color: var(--muted); min-width: 70px; }
    .bet-input {
      flex: 1; background: var(--bg); border: 1px solid var(--border); border-radius: 8px;
      padding: 0.6rem 0.85rem; color: var(--text); font-size: 0.95rem; font-weight: 600;
      outline: none; transition: border-color 0.2s;
    }
    .bet-input:focus { border-color: var(--accent); }
    .bet-quick { display: flex; gap: 0.3rem; }
    .bet-quick button {
      background: var(--border); border: none; color: var(--muted); padding: 0.35rem 0.6rem;
      border-radius: 6px; font-size: 0.75rem; font-weight: 600; cursor: pointer; transition: all 0.2s;
    }
    .bet-quick button:hover { color: var(--text); background: var(--accent-glow); }

    /* GAME AREA */
    .game-area {
      background: var(--surface); border: 1px solid var(--border); border-radius: 14px;
      padding: 2.5rem; text-align: center; margin-bottom: 1rem; min-height: 280px;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }

    /* RESULT */
    .result {
      padding: 1rem 1.25rem; border-radius: 12px; font-weight: 700; font-size: 1rem;
      text-align: center; margin-bottom: 1rem; display: none;
    }
    .result.win {
      display: block; background: rgba(34,197,94,0.08);
      border: 1px solid rgba(34,197,94,0.25); color: var(--green);
      box-shadow: 0 0 20px rgba(34,197,94,0.05);
    }
    .result.lose {
      display: block; background: rgba(239,68,68,0.08);
      border: 1px solid rgba(239,68,68,0.25); color: var(--red);
      box-shadow: 0 0 20px rgba(239,68,68,0.05);
    }
    .result .payout-amount { font-size: 1.2rem; font-weight: 800; display: block; margin-top: 0.15rem; }

    /* PROVABLY FAIR SEED DISPLAY */
    .seed-display {
      background: var(--bg); border: 1px solid var(--border); border-radius: 8px;
      padding: 0.5rem 0.75rem; margin-top: 0.5rem; font-size: 0.7rem; color: var(--muted);
      font-family: monospace; word-break: break-all; cursor: pointer; transition: border-color 0.2s;
    }
    .seed-display:hover { border-color: var(--accent); }

    /* COIN FLIP */
    .coin {
      width: 150px; height: 150px; border-radius: 50%; display: flex; align-items: center;
      justify-content: center; font-size: 3.5rem; font-weight: 800; margin: 1.5rem 0;
      border: 3px solid var(--border); background: var(--surface2); transition: all 0.3s;
    }
    .coin.flipping { animation: coinflip 0.6s ease-in-out; }
    @keyframes coinflip {
      0% { transform: rotateY(0deg) scale(1); }
      50% { transform: rotateY(900deg) scale(0.8); }
      100% { transform: rotateY(1800deg) scale(1); }
    }
    .coin.heads { border-color: var(--accent); color: var(--accent); }
    .coin.tails { border-color: var(--yellow); color: var(--yellow); }
    .flip-choices { display: flex; gap: 0.5rem; margin-top: 0.5rem; }
    .flip-choice {
      padding: 0.5rem 1.5rem; border-radius: 8px; border: 2px solid var(--border);
      background: transparent; color: var(--text); font-weight: 600; font-size: 0.9rem;
      cursor: pointer; transition: all 0.2s;
    }
    .flip-choice:hover { border-color: var(--accent); }
    .flip-choice.selected { border-color: var(--accent); background: var(--accent-glow); color: var(--accent); }

    /* DICE */
    .dice-display { display: flex; gap: 1rem; margin: 1rem 0; }
    .die {
      width: 100px; height: 100px; background: var(--surface2); border: 2px solid var(--border);
      border-radius: 14px; display: flex; align-items: center; justify-content: center;
      font-size: 2.5rem; font-weight: 800; transition: all 0.3s;
    }
    .die.rolling { animation: shake 0.4s ease-in-out; }
    @keyframes shake {
      0%,100% { transform: rotate(0deg); }
      25% { transform: rotate(-15deg) scale(0.9); }
      75% { transform: rotate(15deg) scale(0.9); }
    }
    .die.hit { border-color: var(--green); color: var(--green); }
    .die.miss { border-color: var(--red); color: var(--red); }
    .dice-slider-wrap { width: 100%; margin: 0.75rem 0; }
    .dice-slider {
      -webkit-appearance: none; width: 100%; height: 6px; border-radius: 3px;
      background: linear-gradient(to right, var(--green) 0%, var(--green) var(--val, 50%), var(--red) var(--val, 50%), var(--red) 100%);
      outline: none; cursor: pointer;
    }
    .dice-slider::-webkit-slider-thumb {
      -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%;
      background: var(--text); cursor: pointer; border: 2px solid var(--bg);
    }
    .dice-labels { display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--muted); }
    .dice-target { font-size: 1.1rem; font-weight: 700; margin: 0.5rem 0; }
    .dice-target span { color: var(--accent); }
    .dice-multi { font-size: 0.85rem; color: var(--muted); }
    .dice-multi span { color: var(--green); font-weight: 600; }

    /* MINES */
    .mines-grid {
      display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px;
      width: 340px; margin: 0.75rem 0;
    }
    .mine-cell {
      width: 62px; height: 62px; background: var(--surface2); border: 1px solid var(--border);
      border-radius: 10px; display: flex; align-items: center; justify-content: center;
      font-size: 1.4rem; cursor: pointer; transition: all 0.15s; user-select: none;
    }
    .mine-cell:hover:not(.revealed) { border-color: var(--accent); background: var(--accent-glow2); }
    .mine-cell.revealed.safe { background: rgba(34,197,94,0.15); border-color: rgba(34,197,94,0.4); color: var(--green); }
    .mine-cell.revealed.bomb { background: rgba(239,68,68,0.15); border-color: rgba(239,68,68,0.4); color: var(--red); }
    .mine-cell.revealed.shown { background: rgba(113,113,122,0.1); border-color: var(--border); color: var(--muted); }
    .mines-info { display: flex; gap: 1.5rem; margin: 0.75rem 0; font-size: 0.85rem; }
    .mines-info span { color: var(--accent); font-weight: 600; }
    .mines-count-row { display: flex; align-items: center; gap: 0.5rem; }
    .mines-count-btn {
      width: 28px; height: 28px; border-radius: 6px; border: 1px solid var(--border);
      background: var(--surface2); color: var(--text); font-weight: 700; cursor: pointer;
      display: flex; align-items: center; justify-content: center; font-size: 0.85rem;
    }
    .mines-count-btn:hover { border-color: var(--accent); }

    /* CRASH */
    .crash-graph {
      width: 100%; height: 260px; background: var(--bg); border-radius: 12px;
      border: 1px solid var(--border); position: relative; overflow: hidden; margin: 0.75rem 0;
    }
    .crash-canvas { width: 100%; height: 100%; }
    .crash-multi {
      font-size: 3rem; font-weight: 800; letter-spacing: -0.03em;
      transition: color 0.2s;
    }
    .crash-multi.live { color: var(--green); }
    .crash-multi.crashed { color: var(--red); }
    .crash-multi.cashed { color: var(--accent); }
    .crash-status { font-size: 0.85rem; color: var(--muted); margin-top: 0.25rem; }

    /* LIMBO */
    .limbo-display {
      font-size: 5rem; font-weight: 800; letter-spacing: -0.03em;
      margin: 1.5rem 0; transition: color 0.3s;
    }
    .limbo-display.win { color: var(--green); }
    .limbo-display.lose { color: var(--red); }
    .limbo-display.idle { color: var(--muted); }
    .limbo-target-display {
      font-size: 0.9rem; color: var(--muted); margin-bottom: 0.5rem;
    }
    .limbo-target-display span { color: var(--accent); font-weight: 700; }
    @keyframes limboSpin {
      0% { transform: scale(0.8); opacity: 0.5; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }
    .limbo-display.spinning { animation: limboSpin 0.4s ease-out; }

    /* KENO */
    .keno-grid {
      display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px;
      width: 100%; max-width: 360px; margin: 0.5rem auto;
    }
    .keno-cell {
      aspect-ratio: 1; background: var(--surface2); border: 1px solid var(--border);
      border-radius: 6px; display: flex; align-items: center; justify-content: center;
      font-size: 0.85rem; font-weight: 700; cursor: pointer; transition: all 0.15s;
      user-select: none;
    }
    .keno-cell:hover:not(.drawn) { border-color: var(--accent); }
    .keno-cell.selected { background: var(--accent-glow); border-color: var(--accent); color: var(--accent); }
    .keno-cell.drawn.hit { background: rgba(255,95,31,0.15); border-color: var(--accent); color: var(--accent); }
    .keno-cell.drawn.miss { background: rgba(113,113,122,0.08); border-color: var(--border); color: var(--muted); opacity: 0.4; }
    .keno-cell.drawn.selected.hit, .keno-cell.selected.drawn.hit, .keno-cell.hit.selected {
      background: rgba(34,197,94,0.25); border-color: var(--green); color: #fff;
      box-shadow: 0 0 12px rgba(34,197,94,0.4), inset 0 0 8px rgba(34,197,94,0.15);
      animation: kenoHitPulse 0.5s ease-out; transform: scale(1.08);
    }
    .keno-cell.drawn.selected.miss, .keno-cell.selected.drawn.miss { background: rgba(239,68,68,0.15); border-color: var(--red); color: var(--red); opacity: 0.7; }
    /* SHARE ON X */
    .share-x-btn { display:inline-block; margin-left:0.5rem; padding:0.2rem 0.6rem; border-radius:6px; border:none; background:#000; color:#fff; font-size:0.7rem; font-weight:700; cursor:pointer; vertical-align:middle; transition:all 0.2s; }
    .share-x-btn:hover { background:#333; }

    @keyframes kenoHitPulse { 0% { transform:scale(1.3); box-shadow:0 0 20px rgba(34,197,94,0.6); } 100% { transform:scale(1.08); box-shadow:0 0 12px rgba(34,197,94,0.4); } }
    .keno-info { font-size: 0.8rem; color: var(--muted); margin: 0.5rem 0; }
    .keno-info span { color: var(--accent); font-weight: 600; }
    .keno-picks { display: flex; gap: 0.25rem; flex-wrap: wrap; margin: 0.5rem 0; }
    .keno-pick-btn {
      padding: 0.25rem 0.5rem; border-radius: 6px; border: 1px solid var(--border);
      background: var(--surface2); color: var(--muted); font-size: 0.7rem; font-weight: 600;
      cursor: pointer; transition: all 0.2s;
    }
    .keno-pick-btn:hover, .keno-pick-btn.active { border-color: var(--accent); color: var(--accent); }

    /* KENO PAYOUT LINE */
    .keno-payout-line { display:flex; gap:0; width:100%; margin-top:0.75rem; border-radius:8px; overflow:hidden; border:1px solid var(--border); }
    .keno-payout-slot { flex:1; text-align:center; padding:0.4rem 0.15rem; font-size:0.65rem; font-weight:700; background:var(--surface); border-right:1px solid var(--border); transition:all 0.2s; }
    .keno-payout-slot:last-child { border-right:none; }
    .keno-payout-slot .slot-hits { display:block; color:var(--muted); font-size:0.55rem; font-weight:600; margin-bottom:0.1rem; }
    .keno-payout-slot .slot-multi { display:block; }
    .keno-payout-slot.zero .slot-multi { color:var(--muted); opacity:0.4; }
    .keno-payout-slot.win .slot-multi { color:var(--green); }
    .keno-payout-slot.big .slot-multi { color:var(--accent); }
    .keno-payout-slot.active { background:rgba(34,197,94,0.15); }

    /* WHEEL - Winna style */
    .wheel-container { position: relative; width: 340px; height: 340px; margin: 1rem auto; }
    .wheel-canvas { width: 100%; height: 100%; }
    .wheel-pointer {
      position: absolute; top: -6px; left: 50%; transform: translateX(-50%);
      width: 0; height: 0; border-left: 14px solid transparent; border-right: 14px solid transparent;
      border-top: 24px solid #fff; z-index: 3; filter: drop-shadow(0 2px 6px rgba(0,0,0,0.6));
    }
    .wheel-center {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 56px; height: 56px; border-radius: 50%; background: linear-gradient(135deg, #222 0%, #111 100%);
      border: 2px solid #444; display: flex; align-items: center; justify-content: center;
      font-weight: 800; font-size: 0.85rem; z-index: 2; color: #fff;
    }
    .wheel-result-text { font-size: 1.5rem; font-weight: 800; margin-top: 0.5rem; text-align: center; }

    /* PLINKO */
    .plinko-container { position: relative; width: 100%; max-width: 500px; margin: 0 auto; }
    .plinko-canvas { width: 100%; border-radius: 10px; background: #0d0d0d; border: 1px solid #1a1a1a; }
    .plinko-risk-row { display: flex; gap: 0.25rem; margin: 0.5rem 0; }
    .plinko-risk-btn {
      padding: 0.3rem 0.6rem; border-radius: 6px; border: 1px solid var(--border);
      background: var(--surface2); color: var(--muted); font-size: 0.75rem; font-weight: 600;
      cursor: pointer; transition: all 0.2s;
    }
    .plinko-risk-btn:hover, .plinko-risk-btn.active { border-color: var(--accent); color: var(--accent); }
    .plinko-rows-row { display: flex; align-items: center; gap: 0.5rem; margin: 0.3rem 0; }
    .plinko-result-text { font-size: 1.3rem; font-weight: 800; margin-top: 0.3rem; }

    /* HILO */
    .hilo-cards { display: flex; gap: 1rem; align-items: center; justify-content: center; margin: 1rem 0; }
    .hilo-card {
      width: 110px; height: 160px; background: var(--surface2); border: 2px solid var(--border);
      border-radius: 12px; display: flex; flex-direction: column; align-items: center; justify-content: center;
      font-weight: 800; transition: all 0.3s; position: relative;
    }
    .hilo-card .card-rank { font-size: 2.2rem; }
    .hilo-card .card-suit { font-size: 1.5rem; margin-top: 0.15rem; }
    .hilo-card.red .card-rank, .hilo-card.red .card-suit { color: var(--red); }
    .hilo-card.black .card-rank, .hilo-card.black .card-suit { color: var(--text); }
    .hilo-card.next { border-style: dashed; border-color: var(--muted); }
    .hilo-card.next .card-rank { color: var(--muted); }
    .hilo-card.win { border-color: var(--green); }
    .hilo-card.lose { border-color: var(--red); }
    .hilo-choices { display: flex; gap: 0.5rem; margin-top: 0.5rem; }
    .hilo-choice {
      padding: 0.5rem 1.5rem; border-radius: 8px; border: 2px solid var(--border);
      background: transparent; color: var(--text); font-weight: 600; font-size: 0.9rem;
      cursor: pointer; transition: all 0.2s;
    }
    .hilo-choice:hover { border-color: var(--accent); }
    .hilo-choice:disabled { opacity: 0.4; cursor: not-allowed; }
    .hilo-streak { font-size: 0.85rem; color: var(--muted); margin-top: 0.3rem; }
    .hilo-streak span { color: var(--green); font-weight: 700; }
    .hilo-multi { font-size: 1.5rem; font-weight: 800; color: var(--accent); margin: 0.25rem 0; }

    /* RUNE TOWER */
    .tower-grid {
      display: flex; flex-direction: column-reverse; gap: 4px; width: 100%; max-width: 320px; margin: 0.5rem auto;
    }
    .tower-floor { display: grid; gap: 4px; }
    .tower-floor.cols-2 { grid-template-columns: 1fr 1fr; }
    .tower-floor.cols-3 { grid-template-columns: 1fr 1fr 1fr; }
    .tower-floor.cols-4 { grid-template-columns: 1fr 1fr 1fr 1fr; }
    .tower-cell {
      height: 52px; background: var(--surface2); border: 1px solid var(--border);
      border-radius: 8px; display: flex; align-items: center; justify-content: center;
      font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.15s;
      user-select: none;
    }
    .tower-cell:hover:not(.revealed) { border-color: var(--accent); background: var(--accent-glow2); }
    .tower-cell.revealed.safe { background: rgba(34,197,94,0.15); border-color: rgba(34,197,94,0.4); color: var(--green); }
    .tower-cell.revealed.trap { background: rgba(239,68,68,0.15); border-color: rgba(239,68,68,0.4); color: var(--red); }
    .tower-cell.revealed.shown { background: rgba(113,113,122,0.1); border-color: var(--border); color: var(--muted); }
    .tower-cell.locked { opacity: 0.3; cursor: not-allowed; }
    .tower-cell.current { border-color: var(--accent); }
    .tower-floor-label {
      font-size: 0.65rem; color: var(--muted); text-align: right; padding-right: 0.25rem;
      min-width: 30px;
    }
    .tower-info { display: flex; gap: 1.5rem; margin: 0.5rem 0; font-size: 0.85rem; }
    .tower-info span { color: var(--accent); font-weight: 600; }
    .tower-diff-row { display: flex; gap: 0.25rem; margin: 0.5rem 0; }
    .tower-diff-btn {
      padding: 0.3rem 0.6rem; border-radius: 6px; border: 1px solid var(--border);
      background: var(--surface2); color: var(--muted); font-size: 0.75rem; font-weight: 600;
      cursor: pointer; transition: all 0.2s;
    }
    .tower-diff-btn:hover, .tower-diff-btn.active { border-color: var(--accent); color: var(--accent); }

    /* HISTORY */
    .history-list { display: flex; flex-direction: column; gap: 0; }
    .history-item {
      display: grid; grid-template-columns: 1fr 1fr 1fr; align-items: center;
      font-size: 0.8rem; padding: 0.6rem 0.75rem; border-bottom: 1px solid var(--border);
      background: var(--surface); transition: background 0.15s;
    }
    .history-item:nth-child(even) { background: var(--surface2); }
    .history-item:hover { background: rgba(255,255,255,0.03); }
    .history-game { color: var(--muted); font-weight: 500; }
    .history-result { font-weight: 600; text-align: right; }
    .history-result.win { color: var(--green); }
    .history-result.lose { color: var(--red); }

    /* PROVABLY FAIR PAGE */
    .fair-container { max-width: 620px; margin: 0 auto; padding: 2rem; }
    .fair-container h2 { font-size: 1.3rem; font-weight: 700; margin-bottom: 0.5rem; }
    .fair-container h3 { font-size: 1rem; font-weight: 700; margin: 1.5rem 0 0.5rem; color: var(--accent); }
    .fair-container p { color: var(--muted); font-size: 0.85rem; line-height: 1.7; margin-bottom: 0.75rem; }
    .fair-container code {
      background: var(--surface); border: 1px solid var(--border); border-radius: 6px;
      padding: 0.15rem 0.4rem; font-size: 0.8rem; color: var(--accent);
    }
    .fair-card {
      background: var(--surface); border: 1px solid var(--border); border-radius: 12px;
      padding: 1.25rem; margin: 1rem 0;
    }
    .fair-card label { display: block; font-size: 0.8rem; color: var(--muted); margin-bottom: 0.3rem; }
    .fair-card input, .fair-card textarea {
      width: 100%; background: var(--bg); border: 1px solid var(--border); border-radius: 8px;
      padding: 0.5rem 0.75rem; color: var(--text); font-size: 0.85rem; font-family: monospace;
      outline: none; margin-bottom: 0.75rem; resize: vertical;
    }
    .fair-card input:focus, .fair-card textarea:focus { border-color: var(--accent); }
    .verify-result {
      padding: 0.75rem; border-radius: 8px; font-size: 0.85rem; font-weight: 600; display: none;
    }
    .verify-result.pass { display: block; background: rgba(34,197,94,0.1); border: 1px solid rgba(34,197,94,0.3); color: var(--green); }
    .verify-result.fail { display: block; background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); color: var(--red); }
    .shield-icon {
      display: inline-flex; align-items: center; gap: 0.3rem; background: rgba(34,197,94,0.1);
      border: 1px solid rgba(34,197,94,0.3); border-radius: 8px; padding: 0.3rem 0.7rem;
      font-size: 0.8rem; font-weight: 600; color: var(--green); margin-bottom: 1rem;
    }

    /* WALLETS PAGE */
    .wallets-container { max-width: 620px; margin: 0 auto; padding: 2rem; }
    .wallets-container h2 { font-size: 1.3rem; font-weight: 700; margin-bottom: 0.5rem; }
    .wallets-container p { color: var(--muted); font-size: 0.85rem; line-height: 1.7; margin-bottom: 0.75rem; }
    .wallet-card {
      background: var(--surface); border: 1px solid var(--border); border-radius: 14px;
      padding: 1.5rem; margin-bottom: 1.25rem;
    }
    .wallet-card h3 { font-size: 1rem; font-weight: 700; margin-bottom: 0.3rem; display: flex; align-items: center; gap: 0.4rem; }
    .wallet-card .wallet-purpose { color: var(--muted); font-size: 0.8rem; margin-bottom: 1rem; line-height: 1.5; }
    .wallet-addr-box {
      display: flex; align-items: center; gap: 0.5rem; background: var(--bg);
      border: 1px solid var(--border); border-radius: 8px; padding: 0.6rem 0.75rem;
    }
    .wallet-addr-box input {
      flex: 1; background: none; border: none; color: var(--text); font-size: 0.75rem;
      font-family: monospace; outline: none;
    }
    .wallet-addr-box button {
      background: var(--accent); border: none; color: #fff; padding: 0.3rem 0.6rem;
      border-radius: 6px; font-size: 0.75rem; font-weight: 600; cursor: pointer;
      white-space: nowrap;
    }
    .wallet-tag {
      display: inline-block; padding: 0.15rem 0.5rem; border-radius: 6px;
      font-size: 0.7rem; font-weight: 700; letter-spacing: 0.03em;
    }
    .wallet-tag.rune { background: rgba(255,95,31,0.15); color: var(--accent); }
    .wallet-tag.btc { background: rgba(245,158,11,0.15); color: var(--gold); }
    .wallet-tag.ord { background: rgba(168,85,247,0.15); color: var(--purple); }

    /* FOOTER */
    footer {
      border-top: 1px solid var(--border); padding: 2rem; text-align: center;
      color: var(--muted); font-size: 0.75rem; margin-top: 3rem;
    }
    footer a { color: var(--muted); text-decoration: none; }
    footer a:hover { color: var(--text); }
    .footer-links { display: flex; justify-content: center; gap: 1.5rem; margin-bottom: 0.75rem; flex-wrap: wrap; }
    .footer-links a { font-weight: 500; }

    /* WALLET */
    .wallet-btn {
      background: var(--accent); color: #fff; border: none; padding: 0.5rem 1.2rem;
      border-radius: 8px; font-size: 0.85rem; font-weight: 600; cursor: pointer;
      transition: all 0.15s; display: flex; align-items: center; gap: 0.4rem;
    }
    .wallet-btn:hover { opacity: 0.9; }
    .wallet-btn.connected {
      background: var(--surface); border: 1px solid var(--border); color: var(--text);
      font-size: 0.8rem;
    }
    .wallet-btn.connected:hover { border-color: var(--accent); }
    .wallet-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--green); }
    .wallet-modal-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 200;
      display: none; align-items: center; justify-content: center;
      backdrop-filter: blur(4px);
    }
    .wallet-modal-overlay.show { display: flex; }
    .wallet-modal {
      background: var(--surface); border: 1px solid var(--border); border-radius: 16px;
      padding: 2rem; width: 420px; max-width: 90vw; text-align: center;
    }
    .wallet-modal h3 { font-size: 1.1rem; font-weight: 700; margin-bottom: 0.5rem; }
    .wallet-modal p { color: var(--muted); font-size: 0.85rem; margin-bottom: 1.5rem; }
    .wallet-option {
      display: flex; align-items: center; gap: 1rem; padding: 1rem; border: 1px solid var(--border);
      border-radius: 12px; cursor: pointer; transition: all 0.2s; margin-bottom: 0.5rem;
      background: var(--bg);
    }
    .wallet-option:hover { border-color: var(--accent); }
    .wallet-option-icon {
      width: 40px; height: 40px; border-radius: 10px; background: #ee7b30;
      display: flex; align-items: center; justify-content: center; font-weight: 800;
      font-size: 1.1rem; color: #fff; flex-shrink: 0;
    }
    .wallet-option-info { text-align: left; }
    .wallet-option-name { font-weight: 600; font-size: 0.95rem; }
    .wallet-option-desc { color: var(--muted); font-size: 0.75rem; margin-top: 0.1rem; }
    .wallet-modal-close {
      margin-top: 1rem; color: var(--muted); font-size: 0.8rem; cursor: pointer;
      background: none; border: none; transition: color 0.2s;
    }
    .wallet-modal-close:hover { color: var(--text); }
    .wallet-info {
      background: var(--surface); border: 1px solid var(--border); border-radius: 10px;
      padding: 1rem; margin-bottom: 1rem; text-align: left;
    }
    .wallet-info-row {
      display: flex; justify-content: space-between; align-items: center;
      font-size: 0.8rem; margin-bottom: 0.4rem;
    }
    .wallet-info-row:last-child { margin-bottom: 0; }
    .wallet-info-label { color: var(--muted); }
    .wallet-info-value { font-weight: 600; font-family: monospace; font-size: 0.75rem; }

    /* WELCOME TOAST */
    .toast {
      position: fixed; top: -100px; left: 50%; transform: translateX(-50%);
      background: var(--surface); border: 1px solid var(--accent); border-radius: 12px;
      padding: 1rem 1.5rem; z-index: 300; font-size: 0.9rem; font-weight: 600;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4); transition: top 0.4s ease;
      max-width: 90vw; text-align: center;
    }
    .toast.show { top: 1rem; }
    .toast .toast-amount { color: var(--accent); }

    /* SHARE & EARN BUTTON */
    .share-btn {
      background: transparent; border: 1px solid var(--border); color: var(--text);
      padding: 0.4rem 0.8rem; border-radius: 8px; font-size: 0.8rem; font-weight: 600;
      cursor: pointer; transition: all 0.2s; display: none; align-items: center; gap: 0.3rem;
    }
    .share-btn:hover { border-color: var(--accent); color: var(--accent); }
    .share-btn.visible { display: flex; }

    /* REFERRAL MODAL */
    .referral-modal-content { text-align: left; }
    .referral-link-box {
      display: flex; align-items: center; gap: 0.5rem; background: var(--bg);
      border: 1px solid var(--border); border-radius: 8px; padding: 0.6rem 0.75rem;
      margin: 0.75rem 0;
    }
    .referral-link-box input {
      flex: 1; background: none; border: none; color: var(--text); font-size: 0.8rem;
      font-family: monospace; outline: none;
    }
    .referral-link-box button {
      background: var(--accent); border: none; color: #fff; padding: 0.3rem 0.6rem;
      border-radius: 6px; font-size: 0.75rem; font-weight: 600; cursor: pointer;
      white-space: nowrap;
    }
    .referral-stat {
      display: flex; justify-content: space-between; align-items: center;
      padding: 0.5rem 0; border-bottom: 1px solid var(--border); font-size: 0.85rem;
    }
    .referral-stat:last-child { border-bottom: none; }
    .referral-stat-label { color: var(--muted); }
    .referral-stat-value { font-weight: 700; color: var(--accent); }

    /* TIER BADGES */
    .tier-badge {
      display: inline-block; padding: 0.15rem 0.5rem; border-radius: 6px;
      font-size: 0.7rem; font-weight: 700; letter-spacing: 0.03em;
    }
    .tier-badge.starter { background: rgba(113,113,122,0.2); color: var(--muted); }
    .tier-badge.bronze { background: rgba(234,179,8,0.15); color: var(--yellow); }
    .tier-badge.silver { background: rgba(168,162,158,0.2); color: #a8a29e; }
    .tier-badge.gold { background: rgba(245,158,11,0.2); color: var(--gold); }
    .tier-badge.vip { background: rgba(168,85,247,0.2); color: var(--purple); }

    /* LEADERBOARD */
    .leaderboard-section {
      max-width: 560px; margin: 0 auto 2rem; padding: 0 2rem;
    }
    .leaderboard-card {
      background: var(--surface); border: 1px solid var(--border); border-radius: 14px;
      padding: 1.25rem; margin-top: 1rem;
    }
    .leaderboard-card h3 {
      font-size: 0.95rem; font-weight: 700; margin-bottom: 0.75rem;
      display: flex; align-items: center; gap: 0.4rem;
    }
    .leaderboard-entry {
      display: flex; align-items: center; gap: 0.75rem;
      padding: 0.5rem 0; border-bottom: 1px solid var(--border); font-size: 0.82rem;
    }
    .leaderboard-entry:last-child { border-bottom: none; }
    .leaderboard-rank {
      width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center;
      justify-content: center; font-weight: 800; font-size: 0.75rem; flex-shrink: 0;
    }
    .leaderboard-rank.r1 { background: rgba(245,158,11,0.2); color: var(--gold); }
    .leaderboard-rank.r2 { background: rgba(168,162,158,0.2); color: #a8a29e; }
    .leaderboard-rank.r3 { background: rgba(234,179,8,0.15); color: var(--yellow); }
    .leaderboard-rank.r4 { background: var(--border); color: var(--muted); }
    .leaderboard-addr { flex: 1; font-family: monospace; font-size: 0.75rem; color: var(--muted); }
    .leaderboard-count { font-weight: 700; color: var(--accent); }
    .leaderboard-empty { color: var(--muted); font-size: 0.8rem; text-align: center; padding: 1rem; }

    /* FIRST 100 BANNER */
    .first100-banner {
      max-width: 900px; margin: 0 auto; padding: 0 2rem 1.5rem;
    }
    .first100-card {
      background: linear-gradient(135deg, rgba(255,95,31,0.08), rgba(168,85,247,0.08));
      border: 1px solid var(--accent); border-radius: 14px;
      padding: 1.25rem 1.5rem; display: flex; align-items: center; justify-content: space-between;
      gap: 1rem; flex-wrap: wrap; transition: border-color 0.2s, box-shadow 0.2s;
    }
    .first100-card:hover { box-shadow: 0 0 20px rgba(255,95,31,0.15); }
    .first100-left h3 { font-size: 1rem; font-weight: 700; margin-bottom: 0.2rem; }
    .first100-left h3 span { color: var(--accent); }
    .first100-left p { font-size: 0.8rem; color: var(--muted); line-height: 1.5; }
    .first100-counter {
      background: var(--surface); border: 1px solid var(--border); border-radius: 10px;
      padding: 0.6rem 1rem; text-align: center; min-width: 100px;
    }
    .first100-counter .count { font-size: 1.5rem; font-weight: 800; color: var(--accent); }
    .first100-counter .label { font-size: 0.65rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.08em; }

    /* TIERS DISPLAY */
    .tiers-section {
      margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border);
    }
    .tiers-grid {
      display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.4rem; margin-top: 0.5rem;
    }
    .tier-card {
      background: var(--bg); border: 1px solid var(--border); border-radius: 8px;
      padding: 0.5rem; text-align: center; font-size: 0.7rem;
    }
    .tier-card .tier-name { font-weight: 700; margin-bottom: 0.15rem; }
    .tier-card .tier-req { color: var(--muted); }
    .tier-card .tier-reward { color: var(--green); font-weight: 600; margin-top: 0.15rem; }
    .tier-card.active { border-color: var(--accent); background: var(--accent-glow2); }

    /* AUTOBET */
    .mode-tabs { display:flex; gap:0; margin-bottom:0.75rem; }
    .mode-tab { flex:1; padding:0.5rem; border:1px solid var(--border); background:var(--bg); color:var(--muted); font-size:0.8rem; font-weight:600; cursor:pointer; text-align:center; transition:all 0.2s; }
    .mode-tab:first-child { border-radius:8px 0 0 8px; }
    .mode-tab:last-child { border-radius:0 8px 8px 0; }
    .mode-tab.active { background:var(--accent); color:#fff; border-color:var(--accent); }
    .autobet-panel { display:none; background:var(--bg); border:1px solid var(--border); border-radius:10px; padding:0.75rem; margin-top:0.5rem; }
    .autobet-panel.show { display:block; }
    .autobet-row { display:flex; align-items:center; gap:0.5rem; margin-bottom:0.5rem; }
    .autobet-row:last-child { margin-bottom:0; }
    .autobet-label { font-size:0.75rem; color:var(--muted); min-width:90px; }
    .autobet-input { flex:1; background:var(--surface); border:1px solid var(--border); border-radius:6px; padding:0.4rem 0.6rem; color:var(--text); font-size:0.8rem; font-weight:600; outline:none; }
    .autobet-input:focus { border-color:var(--accent); }
    .autobet-select { flex:1; background:var(--surface); border:1px solid var(--border); border-radius:6px; padding:0.4rem 0.6rem; color:var(--text); font-size:0.8rem; font-weight:600; outline:none; cursor:pointer; -webkit-appearance:none; }
    .autobet-btn { width:100%; padding:0.55rem; border-radius:8px; font-size:0.8rem; font-weight:700; cursor:pointer; border:none; color:#fff; transition:all 0.2s; }
    .autobet-btn.start { background:var(--green); }
    .autobet-btn.stop { background:var(--red); animation: autobetPulse 1.5s infinite; }
    @keyframes autobetPulse { 0%,100% { opacity:1; } 50% { opacity:0.7; } }

    /* TURBO MODE */
    .turbo-toggle { display:flex; align-items:center; gap:0.4rem; margin-bottom:0.75rem; cursor:pointer; font-size:0.8rem; color:var(--muted); user-select:none; }
    .turbo-toggle input { display:none; }
    .turbo-switch { width:32px; height:18px; border-radius:9px; background:var(--border); position:relative; transition:background 0.2s; flex-shrink:0; }
    .turbo-switch::after { content:''; width:14px; height:14px; border-radius:50%; background:var(--muted); position:absolute; top:2px; left:2px; transition:all 0.2s; }
    .turbo-toggle input:checked + .turbo-switch { background:var(--accent); }
    .turbo-toggle input:checked + .turbo-switch::after { left:16px; background:#fff; }

    /* HERO FLASH */
    .hero-flash {
      display:inline-block; padding:0.5rem 1.2rem; border-radius:20px; font-size:0.85rem; font-weight:700;
      background:linear-gradient(90deg, var(--accent), #ff8c42, var(--accent)); background-size:200% 100%;
      animation:heroFlash 2s ease-in-out infinite; color:#fff; margin-top:1rem; letter-spacing:0.02em;
      box-shadow:0 0 20px rgba(255,95,31,0.3), 0 0 40px rgba(255,95,31,0.15);
    }
    @keyframes heroFlash {
      0% { background-position:0% 50%; box-shadow:0 0 20px rgba(255,95,31,0.3), 0 0 40px rgba(255,95,31,0.15); }
      50% { background-position:100% 50%; box-shadow:0 0 30px rgba(255,95,31,0.5), 0 0 60px rgba(255,95,31,0.25); }
      100% { background-position:0% 50%; box-shadow:0 0 20px rgba(255,95,31,0.3), 0 0 40px rgba(255,95,31,0.15); }
    }
    .hero-flash-pulse { animation:heroFlash 2s ease-in-out infinite, heroScale 1.5s ease-in-out infinite; }
    @keyframes heroScale { 0%,100% { transform:scale(1); } 50% { transform:scale(1.05); } }

    /* LIMBO RESULTS BAR */
    .limbo-history { display:flex; gap:5px; overflow-x:auto; padding:0.4rem 0.5rem; margin-bottom:0.75rem; scrollbar-width:none; background:var(--bg); border:1px solid var(--border); border-radius:8px; min-height:32px; align-items:center; width:100%; }
    .limbo-history::-webkit-scrollbar { display:none; }
    .limbo-history:empty::before { content:'Previous results appear here'; color:var(--muted); font-size:0.7rem; opacity:0.5; }
    .limbo-history-item { flex-shrink:0; padding:0.2rem 0.6rem; border-radius:4px; font-size:0.72rem; font-weight:700; line-height:1.2; }
    .limbo-history-item.win { background:rgba(34,197,94,0.15); color:var(--green); }
    .limbo-history-item.lose { background:rgba(239,68,68,0.12); color:var(--red); }

    /* KENO BALL ANIMATION */
    .keno-drawn-area { display:flex; flex-wrap:wrap; gap:6px; justify-content:center; margin:0.75rem 0; min-height:44px; }
    .keno-ball { width:38px; height:38px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:800; font-size:0.8rem; animation:kenoBallDrop 0.3s ease-out; position:relative; }
    .keno-ball.hit { background:var(--accent); color:#fff; box-shadow:0 0 12px rgba(255,95,31,0.4); }
    .keno-ball.miss { background:var(--border); color:var(--muted); }
    .keno-ball .ball-win { position:absolute; top:-16px; left:50%; transform:translateX(-50%); font-size:0.65rem; color:var(--green); font-weight:700; white-space:nowrap; animation:ballWinPop 0.5s ease-out; }
    @keyframes kenoBallDrop { 0% { transform:scale(0) translateY(-20px); opacity:0; } 100% { transform:scale(1) translateY(0); opacity:1; } }
    @keyframes ballWinPop { 0% { opacity:0; transform:translateX(-50%) translateY(5px); } 100% { opacity:1; transform:translateX(-50%) translateY(0); } }

    @media (max-width: 900px) {
      .game-grid { grid-template-columns: repeat(3, 1fr); gap: 0.5rem; }
    }
    @media (max-width: 640px) {
      nav { padding: 0.75rem 1rem; }
      .nav-center { display: none; }
      .hamburger { display: flex; }
      .game-container { padding: 1.5rem 1rem; }
      .game-grid { padding: 0 1rem 3rem; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; }
      .game-card { min-height: 140px; padding: 1.1rem 0.75rem 1.8rem; border-radius: 10px; }
      .game-card-icon { font-size: 2.2rem; }
      .game-card h3 { font-size: 0.82rem; }
      .game-card-edge { font-size: 0.6rem; padding: 0.12rem 0.5rem; }
      .hero { padding: 3rem 1.5rem 2rem; }
      .mine-cell { width: 52px; height: 52px; font-size: 1.1rem; }
      .mines-grid { width: 290px; gap: 5px; }
      .coin { width: 120px; height: 120px; font-size: 2.8rem; }
      .die { width: 80px; height: 80px; font-size: 2rem; }
      .first100-card { flex-direction: column; text-align: center; }
      .faucet-card { flex-direction: column; text-align: center; }
      .tiers-grid { grid-template-columns: repeat(2, 1fr); }
      .nav-right { gap: 0.5rem; }
      .share-btn { display: none !important; }
      .balance-display { font-size: 0.75rem; padding: 0.3rem 0.5rem; }
      .keno-grid { grid-template-columns: repeat(5, 1fr); }
      .hilo-card { width: 85px; height: 125px; }
      .hilo-card .card-rank { font-size: 1.6rem; }
      .wheel-container { width: 260px; height: 260px; }
      .originals-header { padding: 0 1rem 0.75rem; }
      .game-title { font-size: 1.4rem; }
      .game-area { padding: 1.75rem; min-height: 240px; }
      .limbo-display { font-size: 3.5rem; }
      .crash-graph { height: 200px; }
    }
  </style>
</head>
<body>

<nav>
  <div class="logo" onclick="showPage('home')">spunk<span>.bet</span></div>
  <div class="nav-center">
    <button class="nav-tab active" onclick="showPage('home')">Games</button>
    <button class="nav-tab" onclick="showPage('leaderboard-page')">Leaderboard</button>
    <button class="nav-tab" onclick="showPage('history-page')">History</button>
    <button class="nav-tab" onclick="showPage('wallets-page')">Wallets</button>
    <button class="nav-tab" onclick="showPage('fair-page')">Provably Fair</button>
  </div>
  <button class="hamburger" id="hamburger-btn" onclick="toggleMobileMenu()">
    <span></span><span></span><span></span>
  </button>
  <div class="nav-right">
    <div class="balance-display"><span id="balance-display">0</span> SPUNK•BET</div>
    <button class="share-btn" id="share-btn" onclick="openReferralModal()">Share &amp; Earn</button>
    <button class="wallet-btn" id="wallet-btn" onclick="handleWalletClick()">Connect Wallet</button>
  </div>
</nav>

<!-- Mobile Menu -->
<div class="mobile-menu" id="mobile-menu">
  <button onclick="showPage('home'); toggleMobileMenu()">Games</button>
  <button onclick="showPage('leaderboard-page'); toggleMobileMenu()">Leaderboard</button>
  <button onclick="showPage('history-page'); toggleMobileMenu()">History</button>
  <button onclick="showPage('wallets-page'); toggleMobileMenu()">Wallets</button>
  <button onclick="showPage('fair-page'); toggleMobileMenu()">Provably Fair</button>
  <button onclick="openReferralModal(); toggleMobileMenu()" id="mobile-share-btn" style="display:none;">Share &amp; Earn</button>
</div>

<!-- Welcome Toast -->
<div class="toast" id="welcome-toast"></div>

<!-- Wallet Modal -->
<div class="wallet-modal-overlay" id="wallet-modal">
  <div class="wallet-modal">
    <h3>Connect Wallet</h3>
    <p>Connect your Bitcoin wallet to play with SPUNK•BET rune</p>
    <div class="wallet-option" onclick="connectXverse()">
      <div class="wallet-option-icon" style="background:#ee7b30;">X</div>
      <div class="wallet-option-info">
        <div class="wallet-option-name">Xverse</div>
        <div class="wallet-option-desc">Bitcoin, Ordinals, Runes & Stacks</div>
      </div>
    </div>
    <div class="wallet-option" onclick="connectUnisat()">
      <div class="wallet-option-icon" style="background:#000;border:1px solid #333;">U</div>
      <div class="wallet-option-info">
        <div class="wallet-option-name">Unisat</div>
        <div class="wallet-option-desc">Bitcoin, Ordinals, BRC-20 & Runes</div>
      </div>
    </div>
    <div class="wallet-option" onclick="connectMagicEden()">
      <div class="wallet-option-icon" style="background:#e42575;">M</div>
      <div class="wallet-option-info">
        <div class="wallet-option-name">Magic Eden</div>
        <div class="wallet-option-desc">Bitcoin, Ordinals & Runes</div>
      </div>
    </div>
    <div id="wallet-install-hint" style="display:none; margin-top:0.75rem; padding:0.75rem; background:var(--bg); border-radius:8px; border:1px solid var(--border);">
      <p style="font-size:0.8rem; color:var(--muted); margin:0;" id="wallet-install-text">Wallet not detected. Install the wallet extension and refresh.</p>
    </div>
    <button class="wallet-modal-close" onclick="closeWalletModal()">Cancel</button>
  </div>
</div>

<!-- Wallet Details Modal -->
<div class="wallet-modal-overlay" id="wallet-details-modal">
  <div class="wallet-modal">
    <h3>Wallet Connected</h3>
    <div class="wallet-info" id="wallet-info-details"></div>
    <div id="wallet-tier-display" style="margin-bottom:1rem;"></div>
    <button class="btn" style="width:100%; margin-bottom:0.5rem;" onclick="disconnectWallet()">Disconnect</button>
    <button class="wallet-modal-close" onclick="closeWalletDetails()">Close</button>
  </div>
</div>

<!-- Referral Modal -->
<div class="wallet-modal-overlay" id="referral-modal">
  <div class="wallet-modal">
    <h3>Share &amp; Earn SPUNK•BET</h3>
    <p>Earn 7,777 SPUNK•BET for every friend who connects. First 100 referrers get bonus rewards!</p>
    <div class="referral-modal-content">
      <div style="font-size:0.8rem; color:var(--muted); margin-bottom:0.25rem;">Your referral link</div>
      <div class="referral-link-box">
        <input type="text" id="referral-link-input" readonly>
        <button onclick="copyReferralLink()">Copy</button>
      </div>
      <div class="referral-stat">
        <span class="referral-stat-label">Your code</span>
        <span class="referral-stat-value" id="referral-code">&mdash;</span>
      </div>
      <div class="referral-stat">
        <span class="referral-stat-label">Friends referred</span>
        <span class="referral-stat-value" id="referral-count">0</span>
      </div>
      <div class="referral-stat">
        <span class="referral-stat-label">Your tier</span>
        <span id="referral-tier"></span>
      </div>
      <div class="referral-stat">
        <span class="referral-stat-label">SPUNK•BET earned</span>
        <span class="referral-stat-value" id="referral-earned">0</span>
      </div>
      <div class="tiers-section">
        <div style="font-size:0.75rem; color:var(--muted); font-weight:600;">REFERRAL TIERS</div>
        <div class="tiers-grid" id="tiers-grid"></div>
      </div>
    </div>
    <button class="btn" style="width:100%; margin-bottom:0.5rem; background:#000; border:1px solid #333;" onclick="shareReferralOnX()">Share on 𝕏</button>
    <button class="wallet-modal-close" onclick="closeReferralModal()">Close</button>
  </div>
</div>

<!-- HOME -->
<div id="home" class="page active">
  <section class="hero">
    <div class="hero-flash hero-flash-pulse" onclick="document.getElementById('faucet-btn').scrollIntoView({behavior:'smooth'});document.getElementById('faucet-btn').click();" style="cursor:pointer;">10,000 FREE SPUNK•BET — Claim Now</div>
    <h1>Play. Bet. <span>Win.</span></h1>
    <p>Provably fair casino games powered by the SPUNK•BET rune on Bitcoin. No accounts, no KYC. Connect and play.</p>
    <div class="shield-icon">Provably Fair</div>
  </section>

  <!-- Faucet Banner -->
  <div class="faucet-banner" id="faucet-banner">
    <div class="faucet-card">
      <div class="faucet-left">
        <h3>Need SPUNK•BET to play? <span>Claim free tokens</span></h3>
        <p>Get 10,000 free SPUNK•BET tokens to try all games. Claim once every 24 hours.</p>
      </div>
      <button class="faucet-btn" id="faucet-btn" onclick="claimFaucet()">Claim 10,000 SPUNK•BET</button>
    </div>
  </div>

  <!-- First 100 Referrers Banner -->
  <div class="first100-banner" id="first100-banner">
    <div class="first100-card">
      <div class="first100-left">
        <h3>First 100 Referrers Get <span>Bonus SPUNK•BET</span></h3>
        <p>Share your referral link and be among the first 100 to refer a friend. Early referrers earn 2x bonus rewards!</p>
        <button class="btn" style="margin-top:0.6rem;padding:0.45rem 1.2rem;font-size:0.8rem;" onclick="shareFirst100()">Share &amp; Claim Your Spot</button>
      </div>
      <div class="first100-counter">
        <div class="count" id="first100-count">100</div>
        <div class="label">Spots Left</div>
      </div>
    </div>
  </div>

  <div class="originals-header">
    <h2>Originals</h2>
    <span class="tag">10 GAMES</span>
  </div>

  <div class="game-grid">
    <div class="game-card" onclick="openGame('keno')">
      <div class="game-card-edge">1,000x</div>
      <div class="game-card-icon">&#127183;</div>
      <h3>Keno</h3>
      <p class="game-card-desc">Pick your numbers</p>
    </div>
    <div class="game-card" onclick="openGame('limbo')">
      <div class="game-card-edge">&#8734;x</div>
      <div class="game-card-icon">&#127756;</div>
      <h3>Limbo</h3>
      <p class="game-card-desc">Beat the target</p>
    </div>
    <div class="game-card" onclick="openGame('dice')">
      <div class="game-card-edge">up to 99x</div>
      <div class="game-card-icon">&#127922;</div>
      <h3>Dice</h3>
      <p class="game-card-desc">Roll under target</p>
    </div>
    <div class="game-card" onclick="openGame('coinflip')">
      <div class="game-card-edge">1.98x</div>
      <div class="game-card-icon">&#x1FA99;</div>
      <h3>Coin Flip</h3>
      <p class="game-card-desc">50/50 classic</p>
    </div>
    <div class="game-card" onclick="openGame('plinko')">
      <div class="game-card-edge">1,000x</div>
      <div class="game-card-icon">&#9899;</div>
      <h3>Plinko</h3>
      <p class="game-card-desc">Drop the ball</p>
    </div>
    <div class="game-card" onclick="openGame('mines')">
      <div class="game-card-edge">24.75x</div>
      <div class="game-card-icon">&#128163;</div>
      <h3>Mines</h3>
      <p class="game-card-desc">Avoid the bombs</p>
    </div>
    <div class="game-card" onclick="openGame('wheel')">
      <div class="game-card-edge">50x</div>
      <div class="game-card-icon">&#127905;</div>
      <h3>Wheel</h3>
      <p class="game-card-desc">Spin to win</p>
    </div>
    <div class="game-card" onclick="openGame('hilo')">
      <div class="game-card-edge">&#8734;x</div>
      <div class="game-card-icon">&#127136;</div>
      <h3>HiLo</h3>
      <p class="game-card-desc">Higher or lower</p>
    </div>
    <div class="game-card" onclick="openGame('crash')">
      <div class="game-card-edge">&#8734;x</div>
      <div class="game-card-icon">&#128200;</div>
      <h3>Crash</h3>
      <p class="game-card-desc">Cash out in time</p>
    </div>
    <div class="game-card" onclick="openGame('tower')">
      <div class="game-card-edge">500x</div>
      <div class="game-card-icon">&#127960;</div>
      <h3>Rune Tower</h3>
      <p class="game-card-desc">Climb the tower</p>
    </div>
  </div>
</div>

<!-- COIN FLIP -->
<div id="coinflip" class="page">
  <div class="game-container">
    <button class="game-back" onclick="showPage('home')">&larr; Back to games</button>
    <div class="game-title">&#x1FA99; Coin Flip</div>
    <div class="game-payout-badge"><span class="payout-label">Max Payout</span><span class="payout-value">1.98x</span></div>
    <div class="bet-controls">
      <div class="bet-row">
        <span class="bet-label">Bet (SPUNK•BET)</span>
        <input type="number" class="bet-input" id="cf-bet" value="100" min="100">
        <div class="bet-quick">
          <button onclick="setBet('cf-bet','half')">&#189;</button>
          <button onclick="setBet('cf-bet','double')">2x</button>
          <button onclick="setBet('cf-bet','max')">Max</button>
        </div>
      </div>
      <div class="bet-row">
        <span class="bet-label">Pick</span>
        <div class="flip-choices">
          <button class="flip-choice selected" id="cf-heads" onclick="pickSide('heads')">Heads</button>
          <button class="flip-choice" id="cf-tails" onclick="pickSide('tails')">Tails</button>
        </div>
      </div>
      <div class="mode-tabs">
        <button class="mode-tab active" onclick="setAutoMode('coinflip',false,this)">Manual</button>
        <button class="mode-tab" onclick="setAutoMode('coinflip',true,this)">Auto</button>
      </div>
      <div class="autobet-panel" id="autobet-coinflip"></div>
      <label class="turbo-toggle"><input type="checkbox" id="turbo-coinflip" onchange="toggleTurbo('coinflip')"><span class="turbo-switch"></span>Turbo</label>
    </div>
    <div id="cf-result" class="result"></div>
    <div class="game-area">
      <div class="coin" id="cf-coin">?</div>
      <div class="seed-display" id="cf-seed" onclick="copySeed('cf-seed')" title="Click to copy seed hash"></div>
    </div>
    <button class="btn" style="width:100%; padding:0.75rem;" onclick="flipCoin()">Flip Coin</button>
  </div>
</div>

<!-- DICE -->
<div id="dice" class="page">
  <div class="game-container">
    <button class="game-back" onclick="showPage('home')">&larr; Back to games</button>
    <div class="game-title">&#127922; Dice</div>
    <div class="game-payout-badge"><span class="payout-label">Max Payout</span><span class="payout-value" id="dice-payout-badge">2.00x</span></div>
    <div class="bet-controls">
      <div class="bet-row">
        <span class="bet-label">Bet (SPUNK•BET)</span>
        <input type="number" class="bet-input" id="dice-bet" value="100" min="100">
        <div class="bet-quick">
          <button onclick="setBet('dice-bet','half')">&#189;</button>
          <button onclick="setBet('dice-bet','double')">2x</button>
          <button onclick="setBet('dice-bet','max')">Max</button>
        </div>
      </div>
      <div class="mode-tabs">
        <button class="mode-tab active" onclick="setAutoMode('dice',false,this)">Manual</button>
        <button class="mode-tab" onclick="setAutoMode('dice',true,this)">Auto</button>
      </div>
      <div class="autobet-panel" id="autobet-dice"></div>
      <label class="turbo-toggle"><input type="checkbox" id="turbo-dice" onchange="toggleTurbo('dice')"><span class="turbo-switch"></span>Turbo</label>
    </div>
    <div id="dice-result" class="result"></div>
    <div class="game-area">
      <div class="dice-target">Roll under <span id="dice-target-val">50</span> to win</div>
      <div class="dice-display">
        <div class="die" id="dice-die">&#8212;</div>
      </div>
      <div class="dice-slider-wrap">
        <input type="range" class="dice-slider" id="dice-slider" min="5" max="95" value="50" oninput="updateDiceSlider()">
        <div class="dice-labels"><span>5</span><span>50</span><span>95</span></div>
      </div>
      <div class="dice-multi">Win chance: <span id="dice-chance">49%</span> &middot; Payout: <span id="dice-payout" style="color:var(--green);font-weight:600">2.00x</span></div>
      <div class="seed-display" id="dice-seed" onclick="copySeed('dice-seed')" title="Click to copy seed hash"></div>
    </div>
    <button class="btn" style="width:100%; padding:0.75rem;" onclick="rollDice()">Roll Dice</button>
  </div>
</div>

<!-- MINES -->
<div id="mines" class="page">
  <div class="game-container">
    <button class="game-back" onclick="showPage('home')">&larr; Back to games</button>
    <div class="game-title">&#128163; Mines</div>
    <div class="game-payout-badge"><span class="payout-label">Max Payout</span><span class="payout-value">24.75x</span></div>
    <div class="bet-controls">
      <div class="bet-row">
        <span class="bet-label">Bet (SPUNK•BET)</span>
        <input type="number" class="bet-input" id="mines-bet" value="100" min="100">
        <div class="bet-quick">
          <button onclick="setBet('mines-bet','half')">&#189;</button>
          <button onclick="setBet('mines-bet','double')">2x</button>
          <button onclick="setBet('mines-bet','max')">Max</button>
        </div>
      </div>
      <div class="bet-row">
        <span class="bet-label">Mines</span>
        <div class="mines-count-row">
          <button class="mines-count-btn" onclick="changeMines(-1)">-</button>
          <span id="mines-count" style="font-weight:700;min-width:24px;text-align:center">3</span>
          <button class="mines-count-btn" onclick="changeMines(1)">+</button>
        </div>
      </div>
      <div class="mode-tabs">
        <button class="mode-tab active" onclick="setAutoMode('mines',false,this)">Manual</button>
        <button class="mode-tab" onclick="setAutoMode('mines',true,this)">Auto</button>
      </div>
      <div class="autobet-panel" id="autobet-mines"></div>
      <label class="turbo-toggle"><input type="checkbox" id="turbo-mines" onchange="toggleTurbo('mines')"><span class="turbo-switch"></span>Turbo</label>
    </div>
    <div id="mines-result" class="result"></div>
    <div class="game-area" style="padding:1.25rem;">
      <div class="mines-grid" id="mines-grid"></div>
      <div class="mines-info">
        <div>Revealed: <span id="mines-revealed">0</span></div>
        <div>Multiplier: <span id="mines-multi">1.00x</span></div>
        <div>Profit: <span id="mines-profit">+0</span> SPUNK•BET</div>
      </div>
      <div class="seed-display" id="mines-seed" onclick="copySeed('mines-seed')" title="Click to copy seed hash" style="width:100%;"></div>
    </div>
    <div style="display:flex;gap:0.5rem;">
      <button class="btn" style="flex:1; padding:0.75rem;" id="mines-start-btn" onclick="startMines()">Start Game</button>
      <button class="btn btn-green" style="flex:1; padding:0.75rem; display:none;" id="mines-cashout-btn" onclick="cashoutMines()">Cash Out</button>
    </div>
  </div>
</div>

<!-- CRASH -->
<div id="crash" class="page">
  <div class="game-container">
    <button class="game-back" onclick="showPage('home')">&larr; Back to games</button>
    <div class="game-title">&#128200; Crash</div>
    <div class="game-payout-badge"><span class="payout-label">Max Payout</span><span class="payout-value">Unlimited</span></div>
    <div class="bet-controls">
      <div class="bet-row">
        <span class="bet-label">Bet (SPUNK•BET)</span>
        <input type="number" class="bet-input" id="crash-bet" value="100" min="100">
        <div class="bet-quick">
          <button onclick="setBet('crash-bet','half')">&#189;</button>
          <button onclick="setBet('crash-bet','double')">2x</button>
          <button onclick="setBet('crash-bet','max')">Max</button>
        </div>
      </div>
      <div class="mode-tabs">
        <button class="mode-tab active" onclick="setAutoMode('crash',false,this)">Manual</button>
        <button class="mode-tab" onclick="setAutoMode('crash',true,this)">Auto</button>
      </div>
      <div class="autobet-panel" id="autobet-crash"></div>
      <label class="turbo-toggle"><input type="checkbox" id="turbo-crash" onchange="toggleTurbo('crash')"><span class="turbo-switch"></span>Turbo</label>
    </div>
    <div id="crash-result" class="result"></div>
    <div class="game-area" style="padding:1.25rem;">
      <div class="crash-graph"><canvas class="crash-canvas" id="crash-canvas"></canvas></div>
      <div class="crash-multi" id="crash-multi">1.00x</div>
      <div class="crash-status" id="crash-status">Place your bet and launch</div>
      <div class="seed-display" id="crash-seed" onclick="copySeed('crash-seed')" title="Click to copy seed hash" style="width:100%;"></div>
    </div>
    <div style="display:flex;gap:0.5rem;">
      <button class="btn" style="flex:1; padding:0.75rem;" id="crash-start-btn" onclick="startCrash()">Launch</button>
      <button class="btn btn-green" style="flex:1; padding:0.75rem; display:none;" id="crash-cashout-btn" onclick="cashoutCrash()">Cash Out</button>
    </div>
  </div>
</div>

<!-- LIMBO -->
<div id="limbo" class="page">
  <div class="game-container">
    <button class="game-back" onclick="showPage('home')">&larr; Back to games</button>
    <div class="game-title">&#127756; Limbo</div>
    <div class="game-payout-badge"><span class="payout-label">Max Payout</span><span class="payout-value">Unlimited</span></div>
    <div class="bet-controls">
      <div class="bet-row">
        <span class="bet-label">Bet (SPUNK•BET)</span>
        <input type="number" class="bet-input" id="limbo-bet" value="100" min="100">
        <div class="bet-quick">
          <button onclick="setBet('limbo-bet','half')">&#189;</button>
          <button onclick="setBet('limbo-bet','double')">2x</button>
          <button onclick="setBet('limbo-bet','max')">Max</button>
        </div>
      </div>
      <div class="bet-row">
        <span class="bet-label">Target</span>
        <input type="number" class="bet-input" id="limbo-target" value="2" min="1.01" max="1000000" step="0.01">
        <div class="bet-quick">
          <button onclick="setLimboTarget(1.5)">1.5x</button>
          <button onclick="setLimboTarget(2)">2x</button>
          <button onclick="setLimboTarget(10)">10x</button>
          <button onclick="setLimboTarget(100)">100x</button>
        </div>
      </div>
      <div class="mode-tabs">
        <button class="mode-tab active" onclick="setAutoMode('limbo',false,this)">Manual</button>
        <button class="mode-tab" onclick="setAutoMode('limbo',true,this)">Auto</button>
      </div>
      <div class="autobet-panel" id="autobet-limbo"></div>
      <label class="turbo-toggle"><input type="checkbox" id="turbo-limbo" onchange="toggleTurbo('limbo')"><span class="turbo-switch"></span>Turbo</label>
    </div>
    <div id="limbo-result" class="result"></div>
    <div class="game-area">
      <div class="limbo-history" id="limbo-history"></div>
      <div class="limbo-target-display">Target: <span id="limbo-target-display">2.00x</span></div>
      <div class="limbo-display idle" id="limbo-display">1.00x</div>
      <div style="font-size:0.8rem; color:var(--muted)">Win chance: <span id="limbo-chance">49.0%</span></div>
      <div class="seed-display" id="limbo-seed" onclick="copySeed('limbo-seed')" title="Click to copy seed hash"></div>
    </div>
    <button class="btn" style="width:100%; padding:0.75rem;" onclick="playLimbo()">Play</button>
  </div>
</div>

<!-- KENO -->
<div id="keno" class="page">
  <div class="game-container">
    <button class="game-back" onclick="showPage('home')">&larr; Back to games</button>
    <div class="game-title">&#127183; Keno</div>
    <div class="game-payout-badge"><span class="payout-label">Max Payout</span><span class="payout-value">1,000x</span></div>
    <div class="bet-controls">
      <div class="bet-row">
        <span class="bet-label">Bet (SPUNK•BET)</span>
        <input type="number" class="bet-input" id="keno-bet" value="100" min="100">
        <div class="bet-quick">
          <button onclick="setBet('keno-bet','half')">&#189;</button>
          <button onclick="setBet('keno-bet','double')">2x</button>
          <button onclick="setBet('keno-bet','max')">Max</button>
        </div>
      </div>
      <div class="bet-row">
        <span class="bet-label">Picks</span>
        <div class="keno-picks">
          <button class="keno-pick-btn" onclick="kenoAutoSelect(1)">1</button>
          <button class="keno-pick-btn" onclick="kenoAutoSelect(3)">3</button>
          <button class="keno-pick-btn active" onclick="kenoAutoSelect(5)">5</button>
          <button class="keno-pick-btn" onclick="kenoAutoSelect(7)">7</button>
          <button class="keno-pick-btn" onclick="kenoAutoSelect(10)">10</button>
        </div>
      </div>
      <div class="bet-row">
        <span class="bet-label">Risk</span>
        <div class="keno-picks">
          <button class="plinko-risk-btn active" id="keno-risk-low" onclick="setKenoRisk('low')">Low</button>
          <button class="plinko-risk-btn" id="keno-risk-med" onclick="setKenoRisk('medium')">Medium</button>
          <button class="plinko-risk-btn" id="keno-risk-high" onclick="setKenoRisk('high')">High</button>
        </div>
      </div>
      <div class="mode-tabs">
        <button class="mode-tab active" onclick="setAutoMode('keno',false,this)">Manual</button>
        <button class="mode-tab" onclick="setAutoMode('keno',true,this)">Auto</button>
      </div>
      <div class="autobet-panel" id="autobet-keno"></div>
      <label class="turbo-toggle"><input type="checkbox" id="turbo-keno" onchange="toggleTurbo('keno')"><span class="turbo-switch"></span>Turbo</label>
    </div>
    <div id="keno-result" class="result"></div>
    <div class="game-area" style="padding:1rem;">
      <div class="keno-drawn-area" id="keno-drawn-area"></div>
      <div class="keno-info">Selected: <span id="keno-selected-count">0</span>/10 &middot; Hits needed for payout: <span id="keno-hits-needed">1</span></div>
      <div class="keno-grid" id="keno-grid"></div>
      <div class="seed-display" id="keno-seed" onclick="copySeed('keno-seed')" title="Click to copy seed hash" style="width:100%;"></div>
    </div>
    <div style="display:flex;gap:0.5rem;">
      <button class="btn btn-outline" style="flex:1; padding:0.75rem;" onclick="initKenoGrid()">Clear</button>
      <button class="btn" style="flex:1; padding:0.75rem;" onclick="playKenoAnimated()">Play Keno</button>
    </div>
    <div class="keno-payout-line" id="keno-payout-line"></div>
  </div>
</div>

<!-- WHEEL -->
<div id="wheel" class="page">
  <div class="game-container">
    <button class="game-back" onclick="showPage('home')">&larr; Back to games</button>
    <div class="game-title">&#127905; Wheel</div>
    <div class="game-payout-badge"><span class="payout-label">Max Payout</span><span class="payout-value">50x</span></div>
    <div class="bet-controls">
      <div class="bet-row">
        <span class="bet-label">Bet (SPUNK•BET)</span>
        <input type="number" class="bet-input" id="wheel-bet" value="100" min="100">
        <div class="bet-quick">
          <button onclick="setBet('wheel-bet','half')">&#189;</button>
          <button onclick="setBet('wheel-bet','double')">2x</button>
          <button onclick="setBet('wheel-bet','max')">Max</button>
        </div>
      </div>
      <div class="bet-row">
        <span class="bet-label">Risk</span>
        <div class="keno-picks">
          <button class="plinko-risk-btn active" id="wheel-risk-low" onclick="setWheelRisk('low')">Low</button>
          <button class="plinko-risk-btn" id="wheel-risk-med" onclick="setWheelRisk('medium')">Medium</button>
          <button class="plinko-risk-btn" id="wheel-risk-high" onclick="setWheelRisk('high')">High</button>
        </div>
      </div>
      <div class="mode-tabs">
        <button class="mode-tab active" onclick="setAutoMode('wheel',false,this)">Manual</button>
        <button class="mode-tab" onclick="setAutoMode('wheel',true,this)">Auto</button>
      </div>
      <div class="autobet-panel" id="autobet-wheel"></div>
      <label class="turbo-toggle"><input type="checkbox" id="turbo-wheel" onchange="toggleTurbo('wheel')"><span class="turbo-switch"></span>Turbo</label>
    </div>
    <div id="wheel-result" class="result"></div>
    <div class="game-area" style="padding:1.25rem;">
      <div class="wheel-container">
        <div class="wheel-pointer"></div>
        <canvas class="wheel-canvas" id="wheel-canvas" width="560" height="560"></canvas>
        <div class="wheel-center" id="wheel-center">SPIN</div>
      </div>
      <div class="wheel-result-text" id="wheel-result-text"></div>
      <div class="seed-display" id="wheel-seed" onclick="copySeed('wheel-seed')" title="Click to copy seed hash" style="width:100%;"></div>
    </div>
    <button class="btn" style="width:100%; padding:0.75rem;" id="wheel-spin-btn" onclick="spinWheel()">Spin</button>
  </div>
</div>

<!-- PLINKO -->
<div id="plinko" class="page">
  <div class="game-container">
    <button class="game-back" onclick="showPage('home')">&larr; Back to games</button>
    <div class="game-title">&#9899; Plinko</div>
    <div class="game-payout-badge"><span class="payout-label">Max Payout</span><span class="payout-value">1,000x</span></div>
    <div class="bet-controls">
      <div class="bet-row">
        <span class="bet-label">Bet (SPUNK•BET)</span>
        <input type="number" class="bet-input" id="plinko-bet" value="100" min="100">
        <div class="bet-quick">
          <button onclick="setBet('plinko-bet','half')">&#189;</button>
          <button onclick="setBet('plinko-bet','double')">2x</button>
          <button onclick="setBet('plinko-bet','max')">Max</button>
        </div>
      </div>
      <div class="bet-row">
        <span class="bet-label">Risk</span>
        <div class="plinko-risk-row">
          <button class="plinko-risk-btn active" id="plinko-risk-low" onclick="setPlinkoRisk('low')">Low</button>
          <button class="plinko-risk-btn" id="plinko-risk-med" onclick="setPlinkoRisk('medium')">Medium</button>
          <button class="plinko-risk-btn" id="plinko-risk-high" onclick="setPlinkoRisk('high')">High</button>
        </div>
      </div>
      <div class="bet-row">
        <span class="bet-label">Rows</span>
        <div class="plinko-rows-row">
          <button class="mines-count-btn" onclick="changePlinkoRows(-2)">-</button>
          <span id="plinko-rows" style="font-weight:700;min-width:24px;text-align:center">12</span>
          <button class="mines-count-btn" onclick="changePlinkoRows(2)">+</button>
        </div>
      </div>
      <div class="mode-tabs">
        <button class="mode-tab active" onclick="setAutoMode('plinko',false,this)">Manual</button>
        <button class="mode-tab" onclick="setAutoMode('plinko',true,this)">Auto</button>
      </div>
      <div class="autobet-panel" id="autobet-plinko"></div>
      <label class="turbo-toggle"><input type="checkbox" id="turbo-plinko" onchange="toggleTurbo('plinko')"><span class="turbo-switch"></span>Turbo</label>
    </div>
    <div id="plinko-result" class="result"></div>
    <div class="game-area" style="padding:1rem;">
      <div class="plinko-container">
        <canvas class="plinko-canvas" id="plinko-canvas" width="800" height="700"></canvas>
      </div>
      <div class="plinko-result-text" id="plinko-result-text"></div>
      <div class="seed-display" id="plinko-seed" onclick="copySeed('plinko-seed')" title="Click to copy seed hash" style="width:100%;"></div>
    </div>
    <button class="btn" style="width:100%; padding:0.75rem;" id="plinko-drop-btn" onclick="dropPlinko()">Drop Ball</button>
  </div>
</div>

<!-- HILO -->
<div id="hilo" class="page">
  <div class="game-container">
    <button class="game-back" onclick="showPage('home')">&larr; Back to games</button>
    <div class="game-title">&#127136; HiLo</div>
    <div class="game-payout-badge"><span class="payout-label">Max Payout</span><span class="payout-value">Unlimited</span></div>
    <div class="bet-controls">
      <div class="bet-row">
        <span class="bet-label">Bet (SPUNK•BET)</span>
        <input type="number" class="bet-input" id="hilo-bet" value="100" min="100">
        <div class="bet-quick">
          <button onclick="setBet('hilo-bet','half')">&#189;</button>
          <button onclick="setBet('hilo-bet','double')">2x</button>
          <button onclick="setBet('hilo-bet','max')">Max</button>
        </div>
      </div>
      <div class="mode-tabs">
        <button class="mode-tab active" onclick="setAutoMode('hilo',false,this)">Manual</button>
        <button class="mode-tab" onclick="setAutoMode('hilo',true,this)">Auto</button>
      </div>
      <div class="autobet-panel" id="autobet-hilo"></div>
      <label class="turbo-toggle"><input type="checkbox" id="turbo-hilo" onchange="toggleTurbo('hilo')"><span class="turbo-switch"></span>Turbo</label>
    </div>
    <div id="hilo-result" class="result"></div>
    <div class="game-area">
      <div class="hilo-cards">
        <div class="hilo-card" id="hilo-current">
          <div class="card-rank">?</div>
          <div class="card-suit"></div>
        </div>
        <div style="font-size:1.5rem;color:var(--muted)">&#8594;</div>
        <div class="hilo-card next" id="hilo-next">
          <div class="card-rank">?</div>
          <div class="card-suit"></div>
        </div>
      </div>
      <div class="hilo-multi" id="hilo-multi">1.00x</div>
      <div class="hilo-streak">Streak: <span id="hilo-streak">0</span></div>
      <div class="hilo-choices" id="hilo-choices">
        <button class="hilo-choice" id="hilo-hi-btn" onclick="guessHiLo('hi')">&#9650; Higher</button>
        <button class="hilo-choice" id="hilo-lo-btn" onclick="guessHiLo('lo')">&#9660; Lower</button>
      </div>
      <div class="seed-display" id="hilo-seed" onclick="copySeed('hilo-seed')" title="Click to copy seed hash" style="width:100%;"></div>
    </div>
    <div style="display:flex;gap:0.5rem;">
      <button class="btn" style="flex:1; padding:0.75rem;" id="hilo-start-btn" onclick="startHiLo()">Deal</button>
      <button class="btn btn-green" style="flex:1; padding:0.75rem; display:none;" id="hilo-cashout-btn" onclick="cashoutHiLo()">Cash Out</button>
    </div>
  </div>
</div>

<!-- RUNE TOWER -->
<div id="tower" class="page">
  <div class="game-container">
    <button class="game-back" onclick="showPage('home')">&larr; Back to games</button>
    <div class="game-title">&#127960; Rune Tower</div>
    <div class="game-payout-badge"><span class="payout-label">Max Payout</span><span class="payout-value">500x</span></div>
    <div class="bet-controls">
      <div class="bet-row">
        <span class="bet-label">Bet (SPUNK•BET)</span>
        <input type="number" class="bet-input" id="tower-bet" value="100" min="100">
        <div class="bet-quick">
          <button onclick="setBet('tower-bet','half')">&#189;</button>
          <button onclick="setBet('tower-bet','double')">2x</button>
          <button onclick="setBet('tower-bet','max')">Max</button>
        </div>
      </div>
      <div class="bet-row">
        <span class="bet-label">Difficulty</span>
        <div class="tower-diff-row">
          <button class="tower-diff-btn active" id="tower-easy" onclick="setTowerDiff('easy')">Easy</button>
          <button class="tower-diff-btn" id="tower-medium" onclick="setTowerDiff('medium')">Medium</button>
          <button class="tower-diff-btn" id="tower-hard" onclick="setTowerDiff('hard')">Hard</button>
          <button class="tower-diff-btn" id="tower-expert" onclick="setTowerDiff('expert')">Expert</button>
        </div>
      </div>
      <div class="mode-tabs">
        <button class="mode-tab active" onclick="setAutoMode('tower',false,this)">Manual</button>
        <button class="mode-tab" onclick="setAutoMode('tower',true,this)">Auto</button>
      </div>
      <div class="autobet-panel" id="autobet-tower"></div>
      <label class="turbo-toggle"><input type="checkbox" id="turbo-tower" onchange="toggleTurbo('tower')"><span class="turbo-switch"></span>Turbo</label>
    </div>
    <div id="tower-result" class="result"></div>
    <div class="game-area" style="padding:1rem;">
      <div class="tower-info">
        <div>Floor: <span id="tower-floor">0</span></div>
        <div>Multiplier: <span id="tower-multi">1.00x</span></div>
        <div>Profit: <span id="tower-profit">+0</span></div>
      </div>
      <div class="tower-grid" id="tower-grid"></div>
      <div class="seed-display" id="tower-seed" onclick="copySeed('tower-seed')" title="Click to copy seed hash" style="width:100%;"></div>
    </div>
    <div style="display:flex;gap:0.5rem;">
      <button class="btn" style="flex:1; padding:0.75rem;" id="tower-start-btn" onclick="startTower()">Start Climb</button>
      <button class="btn btn-green" style="flex:1; padding:0.75rem; display:none;" id="tower-cashout-btn" onclick="cashoutTower()">Cash Out</button>
    </div>
  </div>
</div>

<!-- LEADERBOARD PAGE -->
<div id="leaderboard-page" class="page">
  <div class="game-container">
    <h2 style="font-size:1.3rem;font-weight:700;margin-bottom:0.25rem;">Referral Leaderboard</h2>
    <p style="color:var(--muted);font-size:0.85rem;margin-bottom:1.5rem;">Top referrers earn bonus Spunk.Bet rewards</p>
    <div class="leaderboard-card">
      <h3>Top Referrers</h3>
      <div id="leaderboard-list"></div>
    </div>
    <div class="leaderboard-card" style="margin-top:1rem;">
      <h3>Tier Rewards</h3>
      <div class="tiers-grid" id="leaderboard-tiers"></div>
    </div>
  </div>
</div>

<!-- HISTORY PAGE -->
<div id="history-page" class="page">
  <div class="game-container">
    <h2 style="font-size:1.3rem;font-weight:700;margin-bottom:1rem;">Bet History</h2>
    <div id="history-full-list" class="history-list" style="font-size:0.85rem;">
      <div style="color:var(--muted);text-align:center;padding:2rem;">No bets yet. Go play!</div>
    </div>
  </div>
</div>

<!-- WALLETS PAGE -->
<div id="wallets-page" class="page">
  <div class="wallets-container">
    <h2>Spunk.Bet Wallets</h2>
    <p>These are the official Spunk.Bet wallets. Send runes, BTC, or ordinals to fund rewards, prizes, and payouts for players.</p>

    <div class="wallet-card">
      <h3>House Wallet <span class="wallet-tag rune">RUNES</span> <span class="wallet-tag btc">BTC</span></h3>
      <div class="wallet-purpose">Funds SPUNK•BET rune payouts for faucet claims, referral rewards, and game winnings. Also accepts BTC for operational costs.</div>
      <div class="wallet-addr-box">
        <input type="text" value="bc1pkepg42ctsvsxk499qu02qqyyz88gwjchnjpsu22wmng9rhpfv3jqw2t2hm" readonly id="house-wallet-addr">
        <button onclick="copyWalletAddr('house-wallet-addr')">Copy</button>
      </div>
    </div>

    <div class="wallet-card">
      <h3>Prize Wallet <span class="wallet-tag ord">ORDINALS</span></h3>
      <div class="wallet-purpose">Holds ordinal inscriptions for giveaways, tournament prizes, and special events. Ordinals sent here will be used as player rewards.</div>
      <div class="wallet-addr-box">
        <input type="text" value="bc1p27l6s82w5dek9yffjtlyj58ue2sndxm6zszpcz9zcwqpd4v86n9s5l37xm" readonly id="prize-wallet-addr">
        <button onclick="copyWalletAddr('prize-wallet-addr')">Copy</button>
      </div>
    </div>

    <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:1.25rem;margin-top:1rem;">
      <h3 style="font-size:0.9rem;font-weight:700;margin-bottom:0.5rem;color:var(--green);">Transparency</h3>
      <p style="font-size:0.8rem;color:var(--muted);line-height:1.6;margin:0;">All wallet balances are publicly verifiable on-chain. These are taproot (P2TR) addresses on Bitcoin mainnet. You can verify balances using any Bitcoin block explorer.</p>
    </div>
  </div>
</div>

<!-- PROVABLY FAIR PAGE -->
<div id="fair-page" class="page">
  <div class="fair-container">
    <div class="shield-icon">Provably Fair</div>
    <h2>How We Prove Every Game is Fair</h2>
    <p>Every bet on Spunk.bet uses a provably fair system. Before each game, we generate a seed that determines the outcome. You can verify any bet after it's played.</p>

    <h3>How It Works</h3>
    <p><strong>1. Before the game:</strong> A random server seed is generated and its SHA-256 hash is shown to you. This commits us to the outcome before you bet.</p>
    <p><strong>2. You play:</strong> Your client seed (generated from your session) is combined with the server seed to produce the game result.</p>
    <p><strong>3. After the game:</strong> The raw server seed is revealed. You can hash it yourself to verify it matches the hash shown before the game.</p>

    <h3>The Math</h3>
    <p>The game result is derived from: <code>HMAC-SHA256(serverSeed, clientSeed + nonce)</code>. The first 8 hex characters are converted to a number between 0 and 1, which maps to the game outcome (coin side, dice roll, mine positions, crash point).</p>

    <h3>Verify a Bet</h3>
    <div class="fair-card">
      <label>Server Seed (revealed after game)</label>
      <input type="text" id="verify-server" placeholder="Paste the revealed server seed">
      <label>Server Seed Hash (shown before game)</label>
      <input type="text" id="verify-hash" placeholder="Paste the hash that was displayed">
      <label>Client Seed</label>
      <input type="text" id="verify-client" placeholder="Your client seed">
      <label>Nonce</label>
      <input type="number" id="verify-nonce" placeholder="Game number" value="0">
      <button class="btn" style="width:100%;" onclick="verifyBet()">Verify</button>
      <div class="verify-result" id="verify-result" style="margin-top:0.75rem;"></div>
    </div>

    <h3>Your Current Seeds</h3>
    <div class="fair-card">
      <label>Client Seed (yours)</label>
      <input type="text" id="my-client-seed" readonly>
      <label>Next Server Seed Hash (our commitment)</label>
      <input type="text" id="my-server-hash" readonly>
      <label>Games Played (nonce)</label>
      <input type="text" id="my-nonce" readonly>
      <button class="btn btn-outline" style="width:100%; margin-top:0.25rem;" onclick="rotateClientSeed()">Rotate Client Seed</button>
    </div>
  </div>
</div>

<footer>
  <div class="footer-links">
    <a href="javascript:showPage('wallets-page')">Wallets</a>
    <a href="javascript:showPage('fair-page')">Provably Fair</a>
    <a href="https://x.com/SpunkArt13" target="_blank">@SpunkArt13</a>
  </div>
  <p>spunk.bet &mdash; powered by SPUNK•BET rune on Bitcoin</p>
  <p style="margin-top:0.5rem; opacity:0.5;">Playing with SPUNK•BET rune tokens &middot; All games are provably fair</p>
</footer>

<script>
// ===== PROVABLY FAIR SYSTEM =====
// Uses SHA-256 HMAC for seed-based outcome generation
// Server seed is committed (hashed) before each game, revealed after

function generateRandomHex(bytes) {
  const arr = new Uint8Array(bytes);
  crypto.getRandomValues(arr);
  return Array.from(arr, b => b.toString(16).padStart(2, '0')).join('');
}

async function sha256(message) {
  const encoder = new TextEncoder();
  const data = encoder.encode(message);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(hashBuffer), b => b.toString(16).padStart(2, '0')).join('');
}

async function hmacSha256(key, message) {
  const encoder = new TextEncoder();
  const keyData = encoder.encode(key);
  const msgData = encoder.encode(message);
  const cryptoKey = await crypto.subtle.importKey('raw', keyData, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
  const sig = await crypto.subtle.sign('HMAC', cryptoKey, msgData);
  return Array.from(new Uint8Array(sig), b => b.toString(16).padStart(2, '0')).join('');
}

// Provably fair state
let pfState = {
  clientSeed: '',
  serverSeed: '',
  serverSeedHash: '',
  nonce: 0
};

async function initProvablyFair() {
  const saved = localStorage.getItem('spunkbet_pf');
  if (saved) {
    try { pfState = JSON.parse(saved); } catch(e) {}
  }
  if (!pfState.clientSeed) {
    pfState.clientSeed = generateRandomHex(16);
  }
  if (!pfState.serverSeed) {
    await rotateServerSeed();
  }
  savePFState();
  updatePFDisplay();
}

async function rotateServerSeed() {
  pfState.serverSeed = generateRandomHex(32);
  pfState.serverSeedHash = await sha256(pfState.serverSeed);
}

function savePFState() {
  localStorage.setItem('spunkbet_pf', JSON.stringify(pfState));
}

async function rotateClientSeed() {
  pfState.clientSeed = generateRandomHex(16);
  pfState.nonce = 0;
  await rotateServerSeed();
  savePFState();
  updatePFDisplay();
  showToast('Client seed rotated. Server seed reset.');
}

function updatePFDisplay() {
  const cs = document.getElementById('my-client-seed');
  const sh = document.getElementById('my-server-hash');
  const nc = document.getElementById('my-nonce');
  if (cs) cs.value = pfState.clientSeed;
  if (sh) sh.value = pfState.serverSeedHash;
  if (nc) nc.value = pfState.nonce;
}

// Get a provably fair random number between 0 and 1
async function fairRandom() {
  const hash = await hmacSha256(pfState.serverSeed, pfState.clientSeed + ':' + pfState.nonce);
  pfState.nonce++;
  // Use first 8 hex chars = 4 bytes = 32 bits
  const num = parseInt(hash.substring(0, 8), 16);
  return num / 0x100000000; // 0 to 0.999...
}

// Show seed info on a game's seed display element
async function showGameSeed(elementId, serverSeed, serverSeedHash) {
  const el = document.getElementById(elementId);
  if (!el) return;
  el.innerHTML = 'Seed hash: ' + serverSeedHash.substring(0, 16) + '... | Server seed: ' + serverSeed.substring(0, 8) + '... <span style="color:var(--accent)">(click to copy full data)</span>';
  el.dataset.fullSeed = JSON.stringify({ serverSeed, serverSeedHash, clientSeed: pfState.clientSeed, nonce: pfState.nonce - 1 });
}

function copySeed(elementId) {
  const el = document.getElementById(elementId);
  if (!el || !el.dataset.fullSeed) return;
  navigator.clipboard.writeText(el.dataset.fullSeed).then(() => {
    showToast('Seed data copied! Paste into Provably Fair verifier.');
  });
}

async function verifyBet() {
  const server = document.getElementById('verify-server').value.trim();
  const hash = document.getElementById('verify-hash').value.trim();
  const client = document.getElementById('verify-client').value.trim();
  const nonce = document.getElementById('verify-nonce').value.trim();
  const resultEl = document.getElementById('verify-result');

  if (!server || !hash) {
    resultEl.className = 'verify-result fail';
    resultEl.textContent = 'Please enter server seed and hash.';
    return;
  }

  const computedHash = await sha256(server);
  if (computedHash === hash) {
    let extra = '';
    if (client) {
      const hmac = await hmacSha256(server, client + ':' + nonce);
      const num = parseInt(hmac.substring(0, 8), 16) / 0x100000000;
      extra = ' | Outcome value: ' + num.toFixed(8) + ' (HMAC: ' + hmac.substring(0, 16) + '...)';
    }
    resultEl.className = 'verify-result pass';
    resultEl.textContent = 'VERIFIED: Server seed matches the committed hash.' + extra;
  } else {
    resultEl.className = 'verify-result fail';
    resultEl.textContent = 'FAILED: Hash mismatch. Expected ' + computedHash.substring(0, 16) + '... but got ' + hash.substring(0, 16) + '...';
  }
}

// ===== STATE =====
let balance = 0;
let history = [];
let cfSide = 'heads';

// ===== REFERRAL TIER CONFIG =====
const TIERS = [
  { name: 'Starter', min: 0, reward: 7777, css: 'starter' },
  { name: 'Bronze', min: 3, reward: 7777, css: 'bronze' },
  { name: 'Silver', min: 5, reward: 10000, css: 'silver' },
  { name: 'Gold', min: 10, reward: 15000, css: 'gold' },
  { name: 'VIP', min: 25, reward: 25000, css: 'vip' },
];

function getTier(count) {
  let tier = TIERS[0];
  for (const t of TIERS) {
    if (count >= t.min) tier = t;
  }
  return tier;
}

function getTierReward(referrerCount) {
  const totalReferrers = getTotalReferrerCount();
  const tier = getTier(referrerCount);
  const isFirst100 = totalReferrers <= 100;
  return isFirst100 ? tier.reward * 2 : tier.reward;
}

function getTotalReferrerCount() {
  let ledger = {};
  try { ledger = JSON.parse(localStorage.getItem('spunkbet_referral_ledger') || '{}'); } catch(e) {}
  return Object.keys(ledger).length;
}

// ===== FAUCET =====
function canClaimFaucet() {
  const lastClaim = localStorage.getItem('spunkbet_faucet_time');
  if (!lastClaim) return true;
  const elapsed = Date.now() - parseInt(lastClaim);
  return elapsed > 24 * 60 * 60 * 1000; // 24 hours
}

function updateFaucetButton() {
  const btn = document.getElementById('faucet-btn');
  if (!btn) return;
  if (canClaimFaucet()) {
    btn.disabled = false;
    btn.textContent = 'Claim 10,000 SPUNK\u2022BET';
  } else {
    btn.disabled = true;
    const lastClaim = parseInt(localStorage.getItem('spunkbet_faucet_time'));
    const nextClaim = lastClaim + 24 * 60 * 60 * 1000;
    const remaining = nextClaim - Date.now();
    const hours = Math.floor(remaining / (60 * 60 * 1000));
    const mins = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
    btn.textContent = 'Claim again in ' + hours + 'h ' + mins + 'm';
  }
}

function claimFaucet() {
  if (!canClaimFaucet()) return;
  balance += 10000;
  localStorage.setItem('spunkbet_faucet_time', Date.now().toString());
  updateBalance();
  saveState();
  updateFaucetButton();
  showToast('Claimed <span class="toast-amount">10,000 SPUNK\u2022BET</span>! Go play some games.');
  // Also send real runes on-chain if wallet is connected
  if (walletState.connected) {
    claimFaucetOnChain();
  }
}

// ===== LOCALSTORAGE PERSISTENCE =====
function saveState() {
  localStorage.setItem('spunkbet_balance', balance.toString());
  localStorage.setItem('spunkbet_history', JSON.stringify(history));
  if (walletState.connected) {
    localStorage.setItem('spunkbet_wallet', JSON.stringify(walletState));
  }
}

function loadState() {
  const savedBalance = localStorage.getItem('spunkbet_balance');
  if (savedBalance !== null) balance = parseInt(savedBalance) || 0;

  const savedHistory = localStorage.getItem('spunkbet_history');
  if (savedHistory) {
    try { history = JSON.parse(savedHistory); } catch(e) { history = []; }
  }

  const savedWallet = localStorage.getItem('spunkbet_wallet');
  if (savedWallet) {
    try {
      const w = JSON.parse(savedWallet);
      if (w.connected) {
        walletState = w;
        updateWalletButton();
        updateShareButton();
      }
    } catch(e) {}
  }

  updateBalance();
  renderHistory();
  updateFirst100();
  renderLeaderboard();
  updateFaucetButton();
}

// ===== REFERRAL CAPTURE =====
function captureReferral() {
  const params = new URLSearchParams(window.location.search);
  const ref = params.get('ref');
  if (ref && ref.length >= 6) {
    if (!localStorage.getItem('spunkbet_referrer')) {
      localStorage.setItem('spunkbet_referrer', ref);
    }
  }
}

// ===== REFERRAL TRACKING =====
function processReferralOnConnect(address) {
  const claimKey = 'spunkbet_claimed_' + address;
  if (localStorage.getItem(claimKey)) return;

  const referrer = localStorage.getItem('spunkbet_referrer');
  const selfRef = address.slice(0, 8);
  const isReferred = referrer && referrer !== selfRef;

  localStorage.setItem(claimKey, Date.now().toString());

  if (isReferred) {
    trackReferral(referrer, address);
    showToast('Welcome! You were referred by <span class="toast-amount">' + referrer + '</span>. Share your own link to earn SPUNK\u2022BET!');
    // Send on-chain referral reward to the referrer
    claimReferralOnChain(address);
  } else {
    showToast('Welcome to <span class="toast-amount">Spunk.bet</span>! Share your referral link to earn SPUNK\u2022BET.');
  }

  updateFirst100();
  renderLeaderboard();
  saveState();
}

function trackReferral(referrerCode, newAddress) {
  let ledger = {};
  try { ledger = JSON.parse(localStorage.getItem('spunkbet_referral_ledger') || '{}'); } catch(e) {}
  if (!ledger[referrerCode]) ledger[referrerCode] = [];
  if (ledger[referrerCode].some(e => e.address === newAddress)) return;
  ledger[referrerCode].push({ address: newAddress, time: Date.now() });
  localStorage.setItem('spunkbet_referral_ledger', JSON.stringify(ledger));
}

function getReferralCount() {
  if (!walletState.connected) return 0;
  const code = walletState.paymentAddress.slice(0, 8);
  let ledger = {};
  try { ledger = JSON.parse(localStorage.getItem('spunkbet_referral_ledger') || '{}'); } catch(e) {}
  return (ledger[code] || []).length;
}

function getReferralEarnings() {
  const count = getReferralCount();
  if (count === 0) return 0;
  let total = 0;
  const tier = getTier(count);
  total = tier.reward * count;
  const totalReferrers = getTotalReferrerCount();
  if (totalReferrers <= 100) total *= 2;
  return total;
}

// ===== FIRST 100 REFERRERS =====
function updateFirst100() {
  const total = getTotalReferrerCount();
  const remaining = Math.max(0, 100 - total);
  const el = document.getElementById('first100-count');
  if (el) el.textContent = remaining;
  const banner = document.getElementById('first100-banner');
  if (banner) banner.style.display = remaining > 0 ? '' : 'none';
}

// ===== LEADERBOARD =====
function renderLeaderboard() {
  let ledger = {};
  try { ledger = JSON.parse(localStorage.getItem('spunkbet_referral_ledger') || '{}'); } catch(e) {}

  const entries = Object.entries(ledger)
    .map(([code, refs]) => ({ code, count: refs.length }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 10);

  const listEl = document.getElementById('leaderboard-list');
  if (!listEl) return;

  if (entries.length === 0) {
    listEl.innerHTML = '<div class="leaderboard-empty">No referrals yet. Be the first!</div>';
  } else {
    listEl.innerHTML = entries.map((e, i) => {
      const rankClass = i < 3 ? 'r' + (i + 1) : 'r4';
      const tier = getTier(e.count);
      return '<div class="leaderboard-entry">' +
        '<div class="leaderboard-rank ' + rankClass + '">' + (i + 1) + '</div>' +
        '<div class="leaderboard-addr">' + e.code + '...</div>' +
        '<span class="tier-badge ' + tier.css + '">' + tier.name + '</span>' +
        '<div class="leaderboard-count">' + e.count + ' refs</div>' +
      '</div>';
    }).join('');
  }

  renderTierCards('leaderboard-tiers', -1);
}

function renderTierCards(containerId, activeCount) {
  const el = document.getElementById(containerId);
  if (!el) return;
  el.innerHTML = TIERS.slice(1).map(t => {
    const isActive = activeCount >= t.min;
    const colorVar = t.css === 'gold' ? 'gold' : t.css === 'vip' ? 'purple' : t.css === 'silver' ? 'muted' : t.css === 'bronze' ? 'yellow' : 'muted';
    return '<div class="tier-card ' + (isActive ? 'active' : '') + '">' +
      '<div class="tier-name" style="color:var(--' + colorVar + ')">' + t.name + '</div>' +
      '<div class="tier-req">' + t.min + '+ refs</div>' +
      '<div class="tier-reward">+' + t.reward + '/ref</div>' +
    '</div>';
  }).join('');
}

// ===== TOAST =====
function showToast(html) {
  const toast = document.getElementById('welcome-toast');
  toast.innerHTML = html;
  setTimeout(() => toast.classList.add('show'), 50);
  setTimeout(() => toast.classList.remove('show'), 4500);
}

// ===== MOBILE MENU =====
function toggleMobileMenu() {
  const menu = document.getElementById('mobile-menu');
  const btn = document.getElementById('hamburger-btn');
  menu.classList.toggle('show');
  btn.classList.toggle('open');
}

// ===== NAVIGATION =====
function showPage(id) {
  document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
  if (id === 'home') document.querySelectorAll('.nav-tab')[0].classList.add('active');
  if (id === 'leaderboard-page') document.querySelectorAll('.nav-tab')[1].classList.add('active');
  if (id === 'history-page') document.querySelectorAll('.nav-tab')[2].classList.add('active');
  if (id === 'wallets-page') document.querySelectorAll('.nav-tab')[3].classList.add('active');
  if (id === 'fair-page') document.querySelectorAll('.nav-tab')[4].classList.add('active');
  if (id === 'leaderboard-page') renderLeaderboard();
  if (id === 'fair-page') updatePFDisplay();
  window.scrollTo(0, 0);
}

function openGame(id) {
  showPage(id);
  if (id === 'dice') updateDiceSlider();
  if (id === 'mines') initMinesGrid();
  if (id === 'limbo') updateLimboDisplay();
  if (id === 'keno') { initKenoGrid(); renderKenoPayoutTable(); }
  if (id === 'wheel') { drawWheel(); }
  if (id === 'plinko') { drawPlinkoBoard(plinkoRows); }
  if (id === 'tower') initTowerGrid();
}

// ===== BALANCE =====
function updateBalance() {
  document.getElementById('balance-display').textContent = balance.toLocaleString();
}

const MIN_BET = 100;

function getBet(id) {
  const v = parseInt(document.getElementById(id).value) || 0;
  if (v < MIN_BET) {
    showToast('Minimum bet is <span class="toast-amount">' + MIN_BET + ' SPUNK•BET</span>');
    return 0;
  }
  return Math.min(v, balance);
}

function setBet(id, action) {
  const el = document.getElementById(id);
  let v = parseInt(el.value) || 100;
  if (action === 'half') v = Math.max(MIN_BET, Math.floor(v / 2));
  if (action === 'double') v = Math.min(balance, v * 2);
  if (action === 'max') v = balance;
  el.value = v;
}

function addHistory(game, bet, result, amount, seedData) {
  history.unshift({ game, bet, result, amount, time: new Date(), seed: seedData || null });
  if (history.length > 50) history.pop();
  if (result === 'win') {
    // Extract multiplier from amount
    const multi = bet > 0 ? ((amount + bet) / bet).toFixed(2) + 'x' : '';
    lastWin = { game, amount: Math.abs(amount), multi };
  }
  renderHistory();
  saveState();
}

function renderHistory() {
  const el = document.getElementById('history-full-list');
  if (history.length === 0) {
    el.innerHTML = '<div style="color:var(--muted);text-align:center;padding:2rem;">No bets yet.</div>';
    return;
  }
  el.innerHTML = history.map(h => {
    const isWin = h.result === 'win';
    const seedBtn = h.seed ? ' <span style="color:var(--accent);cursor:pointer;font-size:0.7rem;" data-seed="' + encodeURIComponent(JSON.stringify(h.seed)) + '" onclick="navigator.clipboard.writeText(decodeURIComponent(this.dataset.seed))">[copy seed]</span>' : '';
    return '<div class="history-item">' +
      '<span class="history-game">' + h.game + seedBtn + '</span>' +
      '<span>' + h.bet + ' SPUNK•BET</span>' +
      '<span class="history-result ' + h.result + '">' + (isWin ? '+' : '-') + Math.abs(h.amount).toLocaleString() + ' SPUNK•BET</span>' +
    '</div>';
  }).join('');
}

let lastWin = { game: '', amount: 0, multi: '' };

function showResult(id, win, msg) {
  const el = document.getElementById(id);
  el.className = 'result ' + (win ? 'win' : 'lose');
  if (win) {
    el.innerHTML = msg + ' <button class="share-x-btn" onclick="shareWinOnX()">Share on 𝕏</button>';
  } else {
    el.textContent = msg;
  }
}

function generateWinCard() {
  const c = document.createElement('canvas');
  c.width = 600; c.height = 314;
  const ctx = c.getContext('2d');
  // Background
  ctx.fillStyle = '#0d0d0d';
  ctx.fillRect(0, 0, 600, 314);
  // Orange accent bar
  ctx.fillStyle = '#ff5f1f';
  ctx.fillRect(0, 0, 600, 4);
  // Logo
  ctx.font = 'bold 22px -apple-system, sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText('spunk', 30, 42);
  ctx.fillStyle = '#ff5f1f';
  ctx.fillText('.bet', 30 + ctx.measureText('spunk').width, 42);
  // Game name
  ctx.font = '600 16px -apple-system, sans-serif';
  ctx.fillStyle = '#71717a';
  ctx.fillText(lastWin.game.toUpperCase(), 30, 100);
  // Win amount
  ctx.font = 'bold 52px -apple-system, sans-serif';
  ctx.fillStyle = '#22c55e';
  ctx.fillText('+' + lastWin.amount.toLocaleString(), 30, 165);
  // SPUNK•BET label
  ctx.font = 'bold 20px -apple-system, sans-serif';
  ctx.fillStyle = '#ff5f1f';
  ctx.fillText('SPUNK•BET', 30, 195);
  // Multiplier
  if (lastWin.multi) {
    ctx.font = 'bold 36px -apple-system, sans-serif';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'right';
    ctx.fillText(lastWin.multi, 570, 165);
    ctx.textAlign = 'left';
  }
  // Footer
  ctx.font = '500 13px -apple-system, sans-serif';
  ctx.fillStyle = '#555';
  ctx.fillText('Provably Fair \u00B7 Bitcoin \u00B7 No KYC', 30, 280);
  // Border
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 1;
  ctx.strokeRect(0, 0, 600, 314);
  return c;
}

async function shareWinOnX() {
  const refCode = walletState.connected ? walletState.paymentAddress.slice(0, 8) : '';
  const link = refCode ? 'https://spunk.bet?ref=' + refCode : 'https://spunk.bet';
  const text = '+' + lastWin.amount.toLocaleString() + ' SPUNK\u2022BET on ' + lastWin.game + '! \uD83C\uDFB0\n\nPlay free \u2192 ' + link;

  // Try Web Share API with image (mobile)
  try {
    const card = generateWinCard();
    const blob = await new Promise(r => card.toBlob(r, 'image/png'));
    const file = new File([blob], 'spunkbet-win.png', { type: 'image/png' });
    if (navigator.canShare && navigator.canShare({ files: [file] })) {
      await navigator.share({ text: text, files: [file] });
      return;
    }
  } catch(e) {}

  // Fallback: download image + open X intent
  try {
    const card = generateWinCard();
    const a = document.createElement('a');
    a.href = card.toDataURL('image/png');
    a.download = 'spunkbet-win.png';
    a.click();
    showToast('Win card saved! Attach it to your tweet.');
  } catch(e) {}

  const url = 'https://x.com/intent/tweet?text=' + encodeURIComponent(text);
  window.open(url, '_blank', 'width=550,height=420');
}

// ===== COIN FLIP =====
function pickSide(side) {
  cfSide = side;
  document.getElementById('cf-heads').classList.toggle('selected', side === 'heads');
  document.getElementById('cf-tails').classList.toggle('selected', side === 'tails');
}

async function flipCoin() {
  const bet = getBet('cf-bet');
  if (bet <= 0 || bet > balance) return;
  balance -= bet;
  updateBalance();

  // Capture current seed for this bet
  const seedBefore = { serverSeedHash: pfState.serverSeedHash, clientSeed: pfState.clientSeed, nonce: pfState.nonce };

  const coin = document.getElementById('cf-coin');
  coin.className = 'coin flipping';
  coin.textContent = '?';

  const rand = await fairRandom();
  const seedAfter = { ...seedBefore, serverSeed: pfState.serverSeed };

  // Rotate server seed for next game
  await rotateServerSeed();
  savePFState();

  const cfDelay = isTurbo('coinflip') ? 50 : 650;
  if (isTurbo('coinflip')) { coin.className = 'coin'; }
  setTimeout(() => {
    const result = rand < 0.5 ? 'heads' : 'tails';
    const win = result === cfSide;
    coin.className = 'coin ' + result;
    coin.textContent = result === 'heads' ? 'H' : 'T';

    showGameSeed('cf-seed', seedAfter.serverSeed, seedAfter.serverSeedHash);

    if (win) {
      const payout = Math.floor(bet * 1.98);
      balance += payout;
      showResult('cf-result', true, result.toUpperCase() + '! You won +' + (payout - bet).toLocaleString() + ' SPUNK•BET');
      addHistory('Coin Flip', bet, 'win', payout - bet, seedAfter);
    } else {
      showResult('cf-result', false, result.toUpperCase() + '. You lost ' + bet.toLocaleString() + ' SPUNK•BET');
      addHistory('Coin Flip', bet, 'lose', -bet, seedAfter);
    }
    updateBalance();
    saveState();
  }, cfDelay);
}

// ===== DICE =====
function updateDiceSlider() {
  const slider = document.getElementById('dice-slider');
  const val = parseInt(slider.value);
  slider.style.setProperty('--val', val + '%');
  document.getElementById('dice-target-val').textContent = val;
  const chance = val - 1;
  document.getElementById('dice-chance').textContent = chance + '%';
  const payout = chance > 0 ? (98 / chance).toFixed(2) : '0.00';
  document.getElementById('dice-payout').textContent = payout + 'x';
  const badge = document.getElementById('dice-payout-badge');
  if (badge) badge.textContent = payout + 'x';
}

async function rollDice() {
  const bet = getBet('dice-bet');
  if (bet > balance || bet <= 0) return;
  const target = parseInt(document.getElementById('dice-slider').value);
  balance -= bet;
  updateBalance();

  const seedBefore = { serverSeedHash: pfState.serverSeedHash, clientSeed: pfState.clientSeed, nonce: pfState.nonce };
  const rand = await fairRandom();
  const seedAfter = { ...seedBefore, serverSeed: pfState.serverSeed };
  await rotateServerSeed();
  savePFState();

  const die = document.getElementById('dice-die');
  if (!isTurbo('dice')) { die.className = 'die rolling'; }
  die.textContent = '?';

  setTimeout(() => {
    const roll = Math.floor(rand * 100) + 1;
    const win = roll < target;
    die.className = 'die ' + (win ? 'hit' : 'miss');
    die.textContent = roll;
    const chance = target - 1;
    const multi = chance > 0 ? (98 / chance) : 0;

    showGameSeed('dice-seed', seedAfter.serverSeed, seedAfter.serverSeedHash);

    if (win) {
      const payout = Math.floor(bet * multi);
      balance += payout;
      showResult('dice-result', true, 'Rolled ' + roll + ' (under ' + target + '). Won +' + (payout - bet).toLocaleString() + ' SPUNK•BET');
      addHistory('Dice', bet, 'win', payout - bet, seedAfter);
    } else {
      showResult('dice-result', false, 'Rolled ' + roll + ' (needed under ' + target + '). Lost ' + bet.toLocaleString() + ' SPUNK•BET');
      addHistory('Dice', bet, 'lose', -bet, seedAfter);
    }
    updateBalance();
    saveState();
  }, isTurbo('dice') ? 50 : 450);
}

// ===== MINES =====
let minesState = null;

function changeMines(d) {
  const el = document.getElementById('mines-count');
  let v = parseInt(el.textContent) + d;
  v = Math.min(24, Math.max(1, v));
  el.textContent = v;
}

function initMinesGrid() {
  const grid = document.getElementById('mines-grid');
  grid.innerHTML = '';
  for (let i = 0; i < 25; i++) {
    const cell = document.createElement('div');
    cell.className = 'mine-cell';
    cell.textContent = '';
    cell.dataset.index = i;
    grid.appendChild(cell);
  }
  document.getElementById('mines-revealed').textContent = '0';
  document.getElementById('mines-multi').textContent = '1.00x';
  document.getElementById('mines-profit').textContent = '+0';
  document.getElementById('mines-result').className = 'result';
  document.getElementById('mines-start-btn').style.display = '';
  document.getElementById('mines-cashout-btn').style.display = 'none';
  minesState = null;
}

function getMinesMulti(revealed, mineCount) {
  let multi = 1;
  for (let i = 0; i < revealed; i++) {
    multi *= (25 - mineCount - i) > 0 ? (25 - i) / (25 - mineCount - i) : 1;
  }
  return multi * 0.98;
}

async function startMines() {
  const bet = getBet('mines-bet');
  if (bet > balance || bet <= 0) return;
  const mineCount = parseInt(document.getElementById('mines-count').textContent);
  balance -= bet;
  updateBalance();
  saveState();
  initMinesGrid();

  const seedBefore = { serverSeedHash: pfState.serverSeedHash, clientSeed: pfState.clientSeed, nonce: pfState.nonce };

  // Generate mine positions using provably fair randomness
  const positions = [];
  const available = Array.from({length: 25}, (_, i) => i);
  for (let i = 0; i < mineCount; i++) {
    const rand = await fairRandom();
    const idx = Math.floor(rand * available.length);
    positions.push(available[idx]);
    available.splice(idx, 1);
  }

  const seedAfter = { ...seedBefore, serverSeed: pfState.serverSeed, nonces: pfState.nonce - 1 };
  await rotateServerSeed();
  savePFState();

  minesState = { bet, mineCount, mines: positions, revealed: 0, active: true, seedData: seedAfter };
  document.getElementById('mines-start-btn').style.display = 'none';
  document.getElementById('mines-cashout-btn').style.display = '';
  showGameSeed('mines-seed', seedAfter.serverSeed, seedAfter.serverSeedHash);

  document.querySelectorAll('.mine-cell').forEach(cell => {
    cell.onclick = () => revealMine(parseInt(cell.dataset.index));
  });
}

function revealMine(index) {
  if (!minesState || !minesState.active) return;
  const cell = document.querySelectorAll('.mine-cell')[index];
  if (cell.classList.contains('revealed')) return;
  if (minesState.mines.includes(index)) {
    cell.classList.add('revealed', 'bomb');
    cell.textContent = '\u{1F4A5}';
    minesState.active = false;
    minesState.mines.forEach(m => {
      const c = document.querySelectorAll('.mine-cell')[m];
      if (!c.classList.contains('revealed')) { c.classList.add('revealed', 'shown'); c.textContent = '\u{1F4A3}'; }
    });
    showResult('mines-result', false, 'BOOM! Lost ' + minesState.bet.toLocaleString() + ' SPUNK•BET');
    addHistory('Mines', minesState.bet, 'lose', -minesState.bet, minesState.seedData);
    document.getElementById('mines-cashout-btn').style.display = 'none';
    document.getElementById('mines-start-btn').style.display = '';
  } else {
    cell.classList.add('revealed', 'safe');
    cell.textContent = '\u{1F48E}';
    minesState.revealed++;
    const multi = getMinesMulti(minesState.revealed, minesState.mineCount);
    const profit = Math.floor(minesState.bet * multi) - minesState.bet;
    document.getElementById('mines-revealed').textContent = minesState.revealed;
    document.getElementById('mines-multi').textContent = multi.toFixed(2) + 'x';
    document.getElementById('mines-profit').textContent = '+' + profit.toLocaleString();
    if (minesState.revealed >= 25 - minesState.mineCount) cashoutMines();
  }
}

function cashoutMines() {
  if (!minesState || !minesState.active) return;
  minesState.active = false;
  const multi = getMinesMulti(minesState.revealed, minesState.mineCount);
  const payout = Math.floor(minesState.bet * multi);
  balance += payout;
  updateBalance();
  const profit = payout - minesState.bet;
  showResult('mines-result', true, 'Cashed out at ' + multi.toFixed(2) + 'x! Won +' + profit.toLocaleString() + ' SPUNK•BET');
  addHistory('Mines', minesState.bet, 'win', profit, minesState.seedData);
  minesState.mines.forEach(m => {
    const c = document.querySelectorAll('.mine-cell')[m];
    c.classList.add('revealed', 'shown'); c.textContent = '\u{1F4A3}';
  });
  document.getElementById('mines-cashout-btn').style.display = 'none';
  document.getElementById('mines-start-btn').style.display = '';
  saveState();
}

// ===== CRASH =====
let crashState = null;

async function startCrash() {
  const bet = getBet('crash-bet');
  if (bet > balance || bet <= 0) return;
  balance -= bet;
  updateBalance();
  saveState();

  const seedBefore = { serverSeedHash: pfState.serverSeedHash, clientSeed: pfState.clientSeed, nonce: pfState.nonce };
  const rand = await fairRandom();
  const seedAfter = { ...seedBefore, serverSeed: pfState.serverSeed };
  await rotateServerSeed();
  savePFState();

  const crashAt = Math.max(1, (0.97 / (1 - rand)));
  crashState = { bet, crashAt, multi: 1.00, active: true, cashed: false, startTime: Date.now(), seedData: seedAfter };
  document.getElementById('crash-start-btn').style.display = 'none';
  document.getElementById('crash-cashout-btn').style.display = '';
  document.getElementById('crash-result').className = 'result';
  document.getElementById('crash-multi').className = 'crash-multi live';
  document.getElementById('crash-status').textContent = 'Rising...';
  showGameSeed('crash-seed', seedAfter.serverSeed, seedAfter.serverSeedHash);

  const canvas = document.getElementById('crash-canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = canvas.offsetWidth * 2;
  canvas.height = canvas.offsetHeight * 2;
  ctx.scale(2, 2);
  animateCrash(ctx, canvas);
}

function animateCrash(ctx, canvas) {
  if (!crashState) return;
  const w = canvas.width / 2, h = canvas.height / 2;
  const elapsed = (Date.now() - crashState.startTime) / 1000;
  const multi = Math.pow(Math.E, elapsed * 0.5);
  crashState.multi = Math.round(multi * 100) / 100;
  document.getElementById('crash-multi').textContent = crashState.multi.toFixed(2) + 'x';
  ctx.clearRect(0, 0, w, h);
  ctx.strokeStyle = crashState.cashed ? '#ff5f1f' : '#22c55e';
  ctx.lineWidth = 2;
  ctx.beginPath();
  const points = 100;
  for (let i = 0; i <= points; i++) {
    const t = (elapsed * i) / points;
    const m = Math.pow(Math.E, t * 0.5);
    const x = (i / points) * w;
    const maxM = Math.max(crashState.multi, 2);
    const y = h - ((m - 1) / (maxM - 1)) * (h - 20);
    if (i === 0) ctx.moveTo(x, Math.min(y, h));
    else ctx.lineTo(x, Math.min(y, h));
  }
  ctx.stroke();
  if (crashState.multi >= crashState.crashAt && !crashState.cashed) {
    crashState.active = false;
    document.getElementById('crash-multi').className = 'crash-multi crashed';
    document.getElementById('crash-multi').textContent = crashState.crashAt.toFixed(2) + 'x';
    document.getElementById('crash-status').textContent = 'Crashed!';
    document.getElementById('crash-cashout-btn').style.display = 'none';
    document.getElementById('crash-start-btn').style.display = '';
    showResult('crash-result', false, 'Crashed at ' + crashState.crashAt.toFixed(2) + 'x. Lost ' + crashState.bet.toLocaleString() + ' SPUNK•BET');
    addHistory('Crash', crashState.bet, 'lose', -crashState.bet, crashState.seedData);
    return;
  }
  if (crashState.cashed) return;
  requestAnimationFrame(() => animateCrash(ctx, canvas));
}

function cashoutCrash() {
  if (!crashState || !crashState.active) return;
  crashState.active = false;
  crashState.cashed = true;
  const payout = Math.floor(crashState.bet * crashState.multi);
  balance += payout;
  updateBalance();
  const profit = payout - crashState.bet;
  document.getElementById('crash-multi').className = 'crash-multi cashed';
  document.getElementById('crash-status').textContent = 'Cashed out at ' + crashState.multi.toFixed(2) + 'x';
  document.getElementById('crash-cashout-btn').style.display = 'none';
  document.getElementById('crash-start-btn').style.display = '';
  showResult('crash-result', true, 'Cashed at ' + crashState.multi.toFixed(2) + 'x! Won +' + profit.toLocaleString() + ' SPUNK•BET');
  addHistory('Crash', crashState.bet, 'win', profit, crashState.seedData);
  saveState();
}

// ===== LIMBO =====
function setLimboTarget(v) {
  document.getElementById('limbo-target').value = v;
  updateLimboDisplay();
}
function updateLimboDisplay() {
  const target = parseFloat(document.getElementById('limbo-target').value) || 2;
  document.getElementById('limbo-target-display').textContent = target.toFixed(2) + 'x';
  const chance = Math.min(98, (98 / target));
  document.getElementById('limbo-chance').textContent = chance.toFixed(1) + '%';
}
async function playLimbo() {
  const bet = getBet('limbo-bet');
  if (bet <= 0 || bet > balance) return;
  const target = parseFloat(document.getElementById('limbo-target').value) || 2;
  if (target < 1.01) { showToast('Target must be at least 1.01x'); return; }
  balance -= bet;
  updateBalance();

  const seedBefore = { serverSeedHash: pfState.serverSeedHash, clientSeed: pfState.clientSeed, nonce: pfState.nonce };
  const rand = await fairRandom();
  const seedAfter = { ...seedBefore, serverSeed: pfState.serverSeed };
  await rotateServerSeed(); savePFState();

  const result = Math.max(1, (0.98 / (1 - rand)));
  const display = document.getElementById('limbo-display');
  if (!isTurbo('limbo')) { display.className = 'limbo-display spinning'; display.textContent = '...'; }

  setTimeout(() => {
    const win = result >= target;
    display.className = 'limbo-display ' + (win ? 'win' : 'lose');
    display.textContent = result.toFixed(2) + 'x';
    addLimboHistory(result, target);
    showGameSeed('limbo-seed', seedAfter.serverSeed, seedAfter.serverSeedHash);
    if (win) {
      const payout = Math.floor(bet * target);
      balance += payout;
      showResult('limbo-result', true, 'Result: ' + result.toFixed(2) + 'x (target ' + target.toFixed(2) + 'x). Won +' + (payout - bet).toLocaleString() + ' SPUNK\u2022BET');
      addHistory('Limbo', bet, 'win', payout - bet, seedAfter);
    } else {
      showResult('limbo-result', false, 'Result: ' + result.toFixed(2) + 'x (needed ' + target.toFixed(2) + 'x). Lost ' + bet.toLocaleString() + ' SPUNK\u2022BET');
      addHistory('Limbo', bet, 'lose', -bet, seedAfter);
    }
    updateBalance(); saveState();
  }, isTurbo('limbo') ? 50 : 400);
}

// ===== KENO =====
let kenoSelected = new Set();
function initKenoGrid() {
  kenoSelected.clear();
  const grid = document.getElementById('keno-grid');
  grid.innerHTML = '';
  const drawnArea = document.getElementById('keno-drawn-area');
  if (drawnArea) drawnArea.innerHTML = '';
  for (let i = 1; i <= 40; i++) {
    const cell = document.createElement('div');
    cell.className = 'keno-cell';
    cell.textContent = i;
    cell.onclick = () => toggleKenoCell(i, cell);
    grid.appendChild(cell);
  }
  document.getElementById('keno-selected-count').textContent = '0';
  document.getElementById('keno-result').className = 'result';
}
function toggleKenoCell(num, cell) {
  if (cell.classList.contains('drawn')) return;
  if (kenoSelected.has(num)) {
    kenoSelected.delete(num);
    cell.classList.remove('selected');
  } else {
    if (kenoSelected.size >= 10) { showToast('Maximum 10 picks'); return; }
    kenoSelected.add(num);
    cell.classList.add('selected');
  }
  document.getElementById('keno-selected-count').textContent = kenoSelected.size;
  document.getElementById('keno-hits-needed').textContent = Math.max(1, Math.ceil(kenoSelected.size * 0.3));
  renderKenoPayoutTable();
}
function kenoAutoSelect(count) {
  initKenoGrid();
  const nums = [];
  while (nums.length < count) {
    const n = Math.floor(Math.random() * 40) + 1;
    if (!nums.includes(n)) nums.push(n);
  }
  const cells = document.querySelectorAll('.keno-cell');
  nums.forEach(n => {
    kenoSelected.add(n);
    cells[n - 1].classList.add('selected');
  });
  document.getElementById('keno-selected-count').textContent = kenoSelected.size;
  document.getElementById('keno-hits-needed').textContent = Math.max(1, Math.ceil(count * 0.3));
  document.querySelectorAll('.keno-pick-btn').forEach(b => {
    b.classList.remove('active');
    if (parseInt(b.textContent) === count) b.classList.add('active');
  });
  renderKenoPayoutTable();
}
let kenoRisk = 'low';
const KENO_TABLES = {
  low: {
    1: [0, 3.6], 2: [0, 1.5, 5.1], 3: [0, 0, 2.2, 20],
    4: [0, 0, 1.5, 5, 50], 5: [0, 0, 0, 2, 10, 100],
    6: [0, 0, 0, 1.5, 4, 20, 200], 7: [0, 0, 0, 1, 2.5, 8, 50, 400],
    8: [0, 0, 0, 0, 2, 5, 20, 100, 500], 9: [0, 0, 0, 0, 1.5, 3, 10, 50, 200, 800],
    10: [0, 0, 0, 0, 1, 2, 5, 20, 80, 300, 1000]
  },
  medium: {
    1: [0, 5], 2: [0, 2, 9], 3: [0, 0, 3.5, 40],
    4: [0, 0, 2, 9, 100], 5: [0, 0, 0, 3, 18, 200],
    6: [0, 0, 0, 2, 7, 40, 400], 7: [0, 0, 0, 1.5, 4, 15, 100, 700],
    8: [0, 0, 0, 0, 3, 9, 40, 200, 1000], 9: [0, 0, 0, 0, 2, 5, 18, 100, 400, 1500],
    10: [0, 0, 0, 0, 1.5, 3, 9, 40, 150, 600, 2000]
  },
  high: {
    1: [0, 8], 2: [0, 0, 17], 3: [0, 0, 0, 80],
    4: [0, 0, 0, 5, 250], 5: [0, 0, 0, 0, 20, 500],
    6: [0, 0, 0, 0, 5, 50, 1000], 7: [0, 0, 0, 0, 3, 20, 200, 1500],
    8: [0, 0, 0, 0, 0, 10, 50, 500, 2500], 9: [0, 0, 0, 0, 0, 5, 25, 200, 800, 4000],
    10: [0, 0, 0, 0, 0, 3, 10, 50, 300, 1000, 5000]
  }
};
function setKenoRisk(risk) {
  kenoRisk = risk;
  ['low','medium','high'].forEach(r => {
    document.getElementById('keno-risk-' + (r === 'medium' ? 'med' : r)).classList.toggle('active', r === risk);
  });
  renderKenoPayoutTable();
}
function getKenoMultiplier(picks, hits) {
  const table = KENO_TABLES[kenoRisk];
  return (table[picks] && table[picks][hits]) || 0;
}
function renderKenoPayoutTable() {
  const container = document.getElementById('keno-payout-line');
  if (!container) return;
  const picks = kenoSelected.size || 5;
  const table = KENO_TABLES[kenoRisk];
  const multis = table[picks] || table[5];
  let html = '';
  for (let i = 0; i <= picks; i++) {
    const m = multis[i] || 0;
    const cls = m >= 50 ? 'big' : m > 0 ? 'win' : 'zero';
    html += '<div class="keno-payout-slot ' + cls + '"><span class="slot-hits">' + i + '/' + picks + '</span><span class="slot-multi">' + (m > 0 ? m + 'x' : '-') + '</span></div>';
  }
  container.innerHTML = html;
}
async function playKeno() {
  if (kenoSelected.size === 0) { showToast('Pick at least 1 number'); return; }
  const bet = getBet('keno-bet');
  if (bet <= 0 || bet > balance) return;
  balance -= bet;
  updateBalance();

  const seedBefore = { serverSeedHash: pfState.serverSeedHash, clientSeed: pfState.clientSeed, nonce: pfState.nonce };
  const drawn = [];
  const avail = Array.from({length: 40}, (_, i) => i + 1);
  for (let i = 0; i < 10; i++) {
    const rand = await fairRandom();
    const idx = Math.floor(rand * avail.length);
    drawn.push(avail[idx]);
    avail.splice(idx, 1);
  }
  const seedAfter = { ...seedBefore, serverSeed: pfState.serverSeed };
  await rotateServerSeed(); savePFState();

  const cells = document.querySelectorAll('.keno-cell');
  const drawnSet = new Set(drawn);
  let hits = 0;
  cells.forEach((cell, i) => {
    const num = i + 1;
    if (drawnSet.has(num)) {
      cell.classList.add('drawn');
      if (kenoSelected.has(num)) { cell.classList.add('hit'); hits++; }
      else cell.classList.add('miss');
    } else if (kenoSelected.has(num)) {
      cell.classList.add('drawn', 'selected', 'miss');
    }
  });

  const multi = getKenoMultiplier(kenoSelected.size, hits);
  showGameSeed('keno-seed', seedAfter.serverSeed, seedAfter.serverSeedHash);
  if (multi > 0) {
    const payout = Math.floor(bet * multi);
    balance += payout;
    showResult('keno-result', true, hits + ' hits! ' + multi + 'x payout. Won +' + (payout - bet).toLocaleString() + ' SPUNK\u2022BET');
    addHistory('Keno', bet, 'win', payout - bet, seedAfter);
  } else {
    showResult('keno-result', false, hits + ' hits. Not enough to win. Lost ' + bet.toLocaleString() + ' SPUNK\u2022BET');
    addHistory('Keno', bet, 'lose', -bet, seedAfter);
  }
  updateBalance(); saveState();
}

// ===== WHEEL =====
let wheelRisk = 'low';
let wheelSpinning = false;
const WHEEL_SEGMENTS = {
  low:    [1.5, 1.2, 1.2, 1.5, 0, 1.2, 1.5, 1.2, 3, 1.2, 1.5, 1.2, 0, 1.2, 1.5, 1.2, 2, 1.2, 1.5, 1.2],
  medium: [2, 0, 1.5, 0, 3, 0, 1.5, 0, 2, 0, 5, 0, 1.5, 0, 2, 0, 1.5, 0, 10, 0],
  high:   [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 0, 0, 0, 50, 0, 0, 0, 0]
};
const WHEEL_COLORS = {
  0: '#2d2d3d', 1.2: '#3b82f6', 1.5: '#6366f1', 2: '#8b5cf6',
  3: '#a855f7', 5: '#ec4899', 10: '#f59e0b', 50: '#22c55e'
};
function setWheelRisk(risk) {
  wheelRisk = risk;
  ['low','medium','high'].forEach(r => {
    document.getElementById('wheel-risk-' + (r === 'medium' ? 'med' : r)).classList.toggle('active', r === risk);
  });
  drawWheel();
}
function drawWheel(rotation) {
  const canvas = document.getElementById('wheel-canvas');
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  const cx = w/2, cy = h/2, r = w/2 - 16;
  ctx.clearRect(0, 0, w, h);
  const segs = WHEEL_SEGMENTS[wheelRisk];
  const angle = (2 * Math.PI) / segs.length;
  const rot = rotation || 0;

  // Outer ring
  ctx.beginPath();
  ctx.arc(cx, cy, r + 8, 0, 2 * Math.PI);
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 3;
  ctx.stroke();

  // Draw segments
  segs.forEach((val, i) => {
    const start = i * angle + rot - Math.PI/2;
    const end = start + angle;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, r, start, end);
    ctx.closePath();
    ctx.fillStyle = WHEEL_COLORS[val] || '#1a1a1a';
    ctx.fill();
    // Segment border
    ctx.strokeStyle = '#0d0d0d';
    ctx.lineWidth = 2;
    ctx.stroke();
  });

  // Inner shadow ring
  const grad = ctx.createRadialGradient(cx, cy, r * 0.85, cx, cy, r);
  grad.addColorStop(0, 'transparent');
  grad.addColorStop(1, 'rgba(0,0,0,0.3)');
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, 2 * Math.PI);
  ctx.fillStyle = grad;
  ctx.fill();

  // Labels
  segs.forEach((val, i) => {
    const start = i * angle + rot - Math.PI/2;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(start + angle / 2);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold ' + (val >= 10 ? '15' : '13') + 'px -apple-system, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 3;
    ctx.fillText(val > 0 ? val + 'x' : '0x', r * 0.72, 0);
    ctx.restore();
  });

  // Center hub
  ctx.beginPath();
  ctx.arc(cx, cy, 32, 0, 2 * Math.PI);
  const hubGrad = ctx.createRadialGradient(cx, cy - 5, 0, cx, cy, 32);
  hubGrad.addColorStop(0, '#222');
  hubGrad.addColorStop(1, '#111');
  ctx.fillStyle = hubGrad;
  ctx.fill();
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 2;
  ctx.stroke();
}
async function spinWheel() {
  if (wheelSpinning) return;
  const bet = getBet('wheel-bet');
  if (bet <= 0 || bet > balance) return;
  balance -= bet; updateBalance();
  wheelSpinning = true;
  document.getElementById('wheel-spin-btn').disabled = true;

  const seedBefore = { serverSeedHash: pfState.serverSeedHash, clientSeed: pfState.clientSeed, nonce: pfState.nonce };
  const rand = await fairRandom();
  const seedAfter = { ...seedBefore, serverSeed: pfState.serverSeed };
  await rotateServerSeed(); savePFState();

  const segs = WHEEL_SEGMENTS[wheelRisk];
  const winIndex = Math.floor(rand * segs.length);
  const segAngle = (2 * Math.PI) / segs.length;
  const targetAngle = -(winIndex * segAngle + segAngle / 2);
  const spins = 5 + Math.random() * 3;
  const totalRotation = spins * 2 * Math.PI + targetAngle;
  const duration = 4000;
  const startTime = Date.now();

  function animateSpin() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(1, elapsed / duration);
    const ease = 1 - Math.pow(1 - progress, 3);
    const currentRotation = ease * totalRotation;
    drawWheel(currentRotation);
    if (progress < 1) {
      requestAnimationFrame(animateSpin);
    } else {
      const val = segs[winIndex];
      document.getElementById('wheel-center').textContent = val > 0 ? val + 'x' : '0';
      showGameSeed('wheel-seed', seedAfter.serverSeed, seedAfter.serverSeedHash);
      if (val > 0) {
        const payout = Math.floor(bet * val);
        balance += payout;
        document.getElementById('wheel-result-text').style.color = 'var(--green)';
        document.getElementById('wheel-result-text').textContent = val + 'x! +' + (payout - bet).toLocaleString();
        showResult('wheel-result', true, 'Landed on ' + val + 'x! Won +' + (payout - bet).toLocaleString() + ' SPUNK\u2022BET');
        addHistory('Wheel', bet, 'win', payout - bet, seedAfter);
      } else {
        document.getElementById('wheel-result-text').style.color = 'var(--red)';
        document.getElementById('wheel-result-text').textContent = '0x - Bust!';
        showResult('wheel-result', false, 'Landed on 0. Lost ' + bet.toLocaleString() + ' SPUNK\u2022BET');
        addHistory('Wheel', bet, 'lose', -bet, seedAfter);
      }
      updateBalance(); saveState();
      wheelSpinning = false;
      document.getElementById('wheel-spin-btn').disabled = false;
    }
  }
  requestAnimationFrame(animateSpin);
}

// ===== PLINKO =====
let plinkoRisk = 'low';
let plinkoRows = 12;
let plinkoDropping = false;
let plinkoBalls = []; // active balls: { path, step, finalSlot, bet, multi, seedAfter, done }
let plinkoAnimRunning = false;
const PLINKO_MULTIS = {
  low:    { 8: [5.6,2.1,1.1,1,0.5,1,1.1,2.1,5.6], 12: [8.9,3,1.4,1.1,1,0.5,0.3,0.5,1,1.1,1.4,3,8.9], 16: [16,9,2,1.4,1.4,1.2,1.1,1,0.5,1,1.1,1.2,1.4,1.4,2,9,16] },
  medium: { 8: [13,3,1.3,0.7,0.4,0.7,1.3,3,13], 12: [24,6,1.7,0.7,0.5,0.2,0.2,0.5,0.7,1.7,6,24], 16: [110,41,10,5,3,1.5,1,0.5,0.3,0.5,1,1.5,3,5,10,41,110] },
  high:   { 8: [29,4,1.5,0.3,0.2,0.3,1.5,4,29], 12: [170,24,8.1,2,0.7,0.2,0.2,0.7,2,8.1,24,170], 16: [1000,130,26,9,4,2,0.2,0.2,0.2,0.2,0.2,2,4,9,26,130,1000] }
};
function setPlinkoRisk(risk) {
  plinkoRisk = risk;
  ['low','medium','high'].forEach(r => {
    document.getElementById('plinko-risk-' + (r === 'medium' ? 'med' : r)).classList.toggle('active', r === risk);
  });
}
function changePlinkoRows(d) {
  plinkoRows = Math.min(16, Math.max(8, plinkoRows + d));
  document.getElementById('plinko-rows').textContent = plinkoRows;
}
function drawPlinkoBoard(rows) {
  const canvas = document.getElementById('plinko-canvas');
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = '#0d0d0d';
  ctx.fillRect(0, 0, w, h);
  const padTop = 40, padBot = 70;
  const rowH = (h - padTop - padBot) / (rows + 1);
  const spacing = (w * 0.75) / (rows + 2);
  // Draw pegs
  for (let r = 0; r < rows; r++) {
    const pegsInRow = r + 3;
    const rowWidth = spacing * pegsInRow;
    const startX = (w - rowWidth) / 2 + spacing / 2;
    for (let p = 0; p < pegsInRow; p++) {
      const x = startX + p * spacing;
      const y = padTop + (r + 1) * rowH;
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, 2 * Math.PI);
      ctx.fillStyle = '#555';
      ctx.fill();
    }
  }
  // Draw multiplier slots
  const multis = PLINKO_MULTIS[plinkoRisk][rows] || PLINKO_MULTIS[plinkoRisk][12];
  const slotCount = multis.length;
  const slotW = (w * 0.88) / slotCount;
  const slotStartX = (w - slotW * slotCount) / 2;
  const slotY = h - padBot + 8;
  const mid = Math.floor(slotCount / 2);
  // Collect hit slots from finished balls
  const hitSlots = new Set();
  plinkoBalls.forEach(b => { if (b.done) hitSlots.add(b.finalSlot); });
  multis.forEach((m, i) => {
    const x = slotStartX + i * slotW;
    const isHit = hitSlots.has(i);
    const dist = Math.abs(i - mid) / mid;
    let color;
    if (plinkoRisk === 'high') {
      color = dist > 0.7 ? '#ff5f1f' : dist > 0.4 ? '#eab308' : '#22c55e';
    } else if (plinkoRisk === 'medium') {
      color = dist > 0.6 ? '#ff5f1f' : dist > 0.3 ? '#eab308' : '#22c55e';
    } else {
      color = dist > 0.7 ? '#eab308' : '#22c55e';
    }
    const alpha = isHit ? 0.5 : 0.15;
    ctx.fillStyle = `rgba(${parseInt(color.slice(1,3),16)},${parseInt(color.slice(3,5),16)},${parseInt(color.slice(5,7),16)},${alpha})`;
    ctx.beginPath();
    ctx.roundRect(x + 1, slotY, slotW - 2, 32, 4);
    ctx.fill();
    if (isHit) {
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.fillStyle = isHit ? '#fff' : color;
    ctx.font = 'bold ' + (slotCount > 13 ? '9' : '11') + 'px -apple-system, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(m + 'x', x + slotW / 2, slotY + 21);
  });
  // Draw all active balls
  plinkoBalls.forEach(ball => {
    const visPath = ball.path.slice(0, Math.min(ball.step + 1, ball.path.length));
    // Trail (last 3 positions only for speed)
    const trailStart = Math.max(0, visPath.length - 4);
    for (let i = trailStart; i < visPath.length - 1; i++) {
      const alpha = 0.08 + ((i - trailStart) / 4) * 0.2;
      ctx.beginPath();
      ctx.arc(visPath[i].x, visPath[i].y, 4, 0, 2 * Math.PI);
      ctx.fillStyle = `rgba(255,95,31,${alpha})`;
      ctx.fill();
    }
    // Ball
    if (visPath.length > 0) {
      const pos = visPath[visPath.length - 1];
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, 7, 0, 2 * Math.PI);
      ctx.fillStyle = '#ff5f1f';
      ctx.fill();
    }
  });
}
function startPlinkoAnimLoop() {
  if (plinkoAnimRunning) return;
  plinkoAnimRunning = true;
  const rows = plinkoRows;
  const turbo = isTurbo('plinko');
  const stepDelay = turbo ? 30 : 60;
  let lastStep = 0;
  function tick(ts) {
    if (plinkoBalls.length === 0) { plinkoAnimRunning = false; return; }
    if (ts - lastStep >= stepDelay) {
      lastStep = ts;
      let anyActive = false;
      plinkoBalls.forEach(ball => {
        if (!ball.done) {
          ball.step++;
          if (ball.step >= ball.path.length) {
            ball.done = true;
            // Resolve this ball
            const multi = ball.multi;
            showGameSeed('plinko-seed', ball.seedAfter.serverSeed, ball.seedAfter.serverSeedHash);
            if (multi >= 1) {
              const payout = Math.floor(ball.bet * multi);
              balance += payout;
              document.getElementById('plinko-result-text').style.color = 'var(--green)';
              document.getElementById('plinko-result-text').textContent = multi + 'x! +' + (payout - ball.bet).toLocaleString();
              showResult('plinko-result', true, multi + 'x! Won +' + (payout - ball.bet).toLocaleString() + ' SPUNK\u2022BET');
              addHistory('Plinko', ball.bet, 'win', payout - ball.bet, ball.seedAfter);
            } else {
              const payout = Math.floor(ball.bet * multi);
              balance += payout;
              document.getElementById('plinko-result-text').style.color = 'var(--red)';
              document.getElementById('plinko-result-text').textContent = multi + 'x \u2212' + (ball.bet - payout).toLocaleString();
              showResult('plinko-result', false, multi + 'x. Lost ' + (ball.bet - payout).toLocaleString() + ' SPUNK\u2022BET');
              addHistory('Plinko', ball.bet, 'lose', -(ball.bet - payout), ball.seedAfter);
            }
            updateBalance(); saveState();
            // Remove finished ball after brief flash
            setTimeout(() => {
              plinkoBalls = plinkoBalls.filter(b => b !== ball);
              if (plinkoBalls.length === 0) drawPlinkoBoard(rows);
            }, 400);
          } else {
            anyActive = true;
          }
        }
      });
    }
    drawPlinkoBoard(rows);
    if (plinkoBalls.some(b => !b.done) || plinkoBalls.length > 0) {
      requestAnimationFrame(tick);
    } else {
      plinkoAnimRunning = false;
    }
  }
  requestAnimationFrame(tick);
}
async function dropPlinko() {
  const bet = getBet('plinko-bet');
  if (bet <= 0 || bet > balance) return;
  balance -= bet; updateBalance();

  const rows = plinkoRows;
  const seedBefore = { serverSeedHash: pfState.serverSeedHash, clientSeed: pfState.clientSeed, nonce: pfState.nonce };
  const directions = [];
  for (let i = 0; i < rows; i++) {
    const r = await fairRandom();
    directions.push(r < 0.5 ? 0 : 1);
  }
  const seedAfter = { ...seedBefore, serverSeed: pfState.serverSeed };
  await rotateServerSeed(); savePFState();

  const canvas = document.getElementById('plinko-canvas');
  const w = canvas.width, h = canvas.height;
  const padTop = 40, padBot = 70;
  const rowH = (h - padTop - padBot) / (rows + 1);
  const spacing = (w * 0.75) / (rows + 2);
  let slot = 0;
  const path = [{ x: w / 2, y: 15 }];
  for (let r = 0; r < rows; r++) {
    if (directions[r] === 1) slot++;
    const pegsInRow = r + 3;
    const rowWidth = spacing * pegsInRow;
    const startX = (w - rowWidth) / 2 + spacing / 2;
    path.push({ x: startX + slot * spacing, y: padTop + (r + 1) * rowH + 8 });
  }
  const multis = PLINKO_MULTIS[plinkoRisk][rows] || PLINKO_MULTIS[plinkoRisk][12];
  const slotCount = multis.length;
  const slotW = (w * 0.88) / slotCount;
  const slotStartX = (w - slotW * slotCount) / 2;
  const finalSlot = Math.min(slot, slotCount - 1);
  path.push({ x: slotStartX + finalSlot * slotW + slotW / 2, y: h - padBot + 24 });

  plinkoBalls.push({ path, step: 0, finalSlot, bet, multi: multis[finalSlot], seedAfter, done: false });
  startPlinkoAnimLoop();
}

// ===== HILO =====
let hiloState = null;
const CARD_RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
const CARD_SUITS = ['\u2665','\u2666','\u2663','\u2660'];
function cardValue(rank) { return CARD_RANKS.indexOf(rank) + 1; }
function renderCard(elId, rank, suit, extraClass) {
  const el = document.getElementById(elId);
  const isRed = suit === '\u2665' || suit === '\u2666';
  el.className = 'hilo-card ' + (isRed ? 'red' : 'black') + (extraClass ? ' ' + extraClass : '');
  el.querySelector('.card-rank').textContent = rank;
  el.querySelector('.card-suit').textContent = suit;
}
async function startHiLo() {
  const bet = getBet('hilo-bet');
  if (bet <= 0 || bet > balance) return;
  balance -= bet; updateBalance(); saveState();

  const seedBefore = { serverSeedHash: pfState.serverSeedHash, clientSeed: pfState.clientSeed, nonce: pfState.nonce };
  const rand = await fairRandom();
  const cardIdx = Math.floor(rand * 52);
  const rank = CARD_RANKS[cardIdx % 13];
  const suit = CARD_SUITS[Math.floor(cardIdx / 13)];

  hiloState = {
    bet, currentRank: rank, currentSuit: suit, streak: 0, multi: 1.00, active: true,
    seedBefore, firstSeed: pfState.serverSeed
  };
  renderCard('hilo-current', rank, suit);
  document.getElementById('hilo-next').className = 'hilo-card next';
  document.getElementById('hilo-next').querySelector('.card-rank').textContent = '?';
  document.getElementById('hilo-next').querySelector('.card-suit').textContent = '';
  document.getElementById('hilo-multi').textContent = '1.00x';
  document.getElementById('hilo-streak').textContent = '0';
  document.getElementById('hilo-result').className = 'result';
  document.getElementById('hilo-start-btn').style.display = 'none';
  document.getElementById('hilo-cashout-btn').style.display = '';
  document.getElementById('hilo-hi-btn').disabled = false;
  document.getElementById('hilo-lo-btn').disabled = false;

  // Calculate odds display
  const val = cardValue(rank);
  const hiChance = (13 - val) / 13;
  const loChance = (val - 1) / 13;
  document.getElementById('hilo-hi-btn').textContent = '\u25B2 Higher (' + Math.round(hiChance * 100) + '%)';
  document.getElementById('hilo-lo-btn').textContent = '\u25BC Lower (' + Math.round(loChance * 100) + '%)';
}
async function guessHiLo(guess) {
  if (!hiloState || !hiloState.active) return;
  document.getElementById('hilo-hi-btn').disabled = true;
  document.getElementById('hilo-lo-btn').disabled = true;

  const rand = await fairRandom();
  const cardIdx = Math.floor(rand * 52);
  const newRank = CARD_RANKS[cardIdx % 13];
  const newSuit = CARD_SUITS[Math.floor(cardIdx / 13)];
  const oldVal = cardValue(hiloState.currentRank);
  const newVal = cardValue(newRank);

  const correct = (guess === 'hi' && newVal >= oldVal) || (guess === 'lo' && newVal <= oldVal);

  setTimeout(() => {
    renderCard('hilo-next', newRank, newSuit, correct ? 'win' : 'lose');
    if (correct) {
      hiloState.streak++;
      const odds = guess === 'hi' ? (13 - oldVal + 1) / 13 : oldVal / 13;
      hiloState.multi *= (0.98 / odds);
      hiloState.multi = Math.round(hiloState.multi * 100) / 100;
      document.getElementById('hilo-multi').textContent = hiloState.multi.toFixed(2) + 'x';
      document.getElementById('hilo-streak').textContent = hiloState.streak;
      // Shift cards
      setTimeout(() => {
        hiloState.currentRank = newRank;
        hiloState.currentSuit = newSuit;
        renderCard('hilo-current', newRank, newSuit);
        document.getElementById('hilo-next').className = 'hilo-card next';
        document.getElementById('hilo-next').querySelector('.card-rank').textContent = '?';
        document.getElementById('hilo-next').querySelector('.card-suit').textContent = '';
        document.getElementById('hilo-hi-btn').disabled = false;
        document.getElementById('hilo-lo-btn').disabled = false;
        const val = cardValue(newRank);
        document.getElementById('hilo-hi-btn').textContent = '\u25B2 Higher (' + Math.round(((13 - val) / 13) * 100) + '%)';
        document.getElementById('hilo-lo-btn').textContent = '\u25BC Lower (' + Math.round(((val - 1) / 13) * 100) + '%)';
      }, 600);
    } else {
      hiloState.active = false;
      const seedAfter = { ...hiloState.seedBefore, serverSeed: hiloState.firstSeed };
      showGameSeed('hilo-seed', seedAfter.serverSeed, seedAfter.serverSeedHash);
      showResult('hilo-result', false, newRank + newSuit + ' was not ' + (guess === 'hi' ? 'higher' : 'lower') + '. Lost ' + hiloState.bet.toLocaleString() + ' SPUNK\u2022BET');
      addHistory('HiLo', hiloState.bet, 'lose', -hiloState.bet, seedAfter);
      document.getElementById('hilo-cashout-btn').style.display = 'none';
      document.getElementById('hilo-start-btn').style.display = '';
    }
  }, 300);
}
function cashoutHiLo() {
  if (!hiloState || !hiloState.active) return;
  hiloState.active = false;
  const payout = Math.floor(hiloState.bet * hiloState.multi);
  balance += payout;
  const profit = payout - hiloState.bet;
  const seedAfter = { ...hiloState.seedBefore, serverSeed: hiloState.firstSeed };
  showGameSeed('hilo-seed', seedAfter.serverSeed, seedAfter.serverSeedHash);
  showResult('hilo-result', true, 'Cashed out at ' + hiloState.multi.toFixed(2) + 'x! Won +' + profit.toLocaleString() + ' SPUNK\u2022BET');
  addHistory('HiLo', hiloState.bet, 'win', profit, seedAfter);
  document.getElementById('hilo-cashout-btn').style.display = 'none';
  document.getElementById('hilo-start-btn').style.display = '';
  updateBalance(); saveState();
}

// ===== RUNE TOWER =====
let towerState = null;
let towerDiff = 'easy';
const TOWER_CONFIG = {
  easy: { cols: 4, traps: 1, floors: 10 },
  medium: { cols: 3, traps: 1, floors: 10 },
  hard: { cols: 2, traps: 1, floors: 10 },
  expert: { cols: 3, traps: 2, floors: 8 }
};
function setTowerDiff(diff) {
  towerDiff = diff;
  ['easy','medium','hard','expert'].forEach(d => {
    document.getElementById('tower-' + d).classList.toggle('active', d === diff);
  });
  initTowerGrid();
}
function getTowerMulti(floor, diff) {
  const cfg = TOWER_CONFIG[diff];
  const safeOdds = (cfg.cols - cfg.traps) / cfg.cols;
  return Math.pow(0.98 / safeOdds, floor);
}
function initTowerGrid() {
  const cfg = TOWER_CONFIG[towerDiff];
  const grid = document.getElementById('tower-grid');
  grid.innerHTML = '';
  for (let f = 0; f < cfg.floors; f++) {
    const floor = document.createElement('div');
    floor.className = 'tower-floor cols-' + cfg.cols;
    floor.dataset.floor = f;
    for (let c = 0; c < cfg.cols; c++) {
      const cell = document.createElement('div');
      cell.className = 'tower-cell' + (f > 0 ? ' locked' : '');
      cell.dataset.floor = f;
      cell.dataset.col = c;
      cell.textContent = f === 0 ? '' : '';
      floor.appendChild(cell);
    }
    grid.appendChild(floor);
  }
  document.getElementById('tower-floor').textContent = '0';
  document.getElementById('tower-multi').textContent = '1.00x';
  document.getElementById('tower-profit').textContent = '+0';
  document.getElementById('tower-result').className = 'result';
  document.getElementById('tower-start-btn').style.display = '';
  document.getElementById('tower-cashout-btn').style.display = 'none';
  towerState = null;
}
async function startTower() {
  const bet = getBet('tower-bet');
  if (bet <= 0 || bet > balance) return;
  balance -= bet; updateBalance(); saveState();

  const cfg = TOWER_CONFIG[towerDiff];
  const seedBefore = { serverSeedHash: pfState.serverSeedHash, clientSeed: pfState.clientSeed, nonce: pfState.nonce };

  // Generate trap positions for each floor
  const traps = [];
  for (let f = 0; f < cfg.floors; f++) {
    const floorTraps = [];
    const avail = Array.from({length: cfg.cols}, (_, i) => i);
    for (let t = 0; t < cfg.traps; t++) {
      const rand = await fairRandom();
      const idx = Math.floor(rand * avail.length);
      floorTraps.push(avail[idx]);
      avail.splice(idx, 1);
    }
    traps.push(floorTraps);
  }
  const seedAfter = { ...seedBefore, serverSeed: pfState.serverSeed };
  await rotateServerSeed(); savePFState();

  towerState = { bet, diff: towerDiff, traps, currentFloor: 0, active: true, seedData: seedAfter, config: cfg };
  initTowerGrid();
  // Unlock floor 0
  document.querySelectorAll('.tower-cell[data-floor="0"]').forEach(cell => {
    cell.classList.remove('locked');
    cell.onclick = () => climbTower(parseInt(cell.dataset.floor), parseInt(cell.dataset.col));
  });
  document.getElementById('tower-start-btn').style.display = 'none';
  document.getElementById('tower-cashout-btn').style.display = '';
  showGameSeed('tower-seed', seedAfter.serverSeed, seedAfter.serverSeedHash);
}
function climbTower(floor, col) {
  if (!towerState || !towerState.active || floor !== towerState.currentFloor) return;
  const cell = document.querySelector('.tower-cell[data-floor="' + floor + '"][data-col="' + col + '"]');
  if (!cell || cell.classList.contains('revealed')) return;

  const isTrapped = towerState.traps[floor].includes(col);
  if (isTrapped) {
    cell.classList.add('revealed', 'trap');
    cell.textContent = '\u2620';
    towerState.active = false;
    // Reveal all traps on this floor
    towerState.traps[floor].forEach(t => {
      const tc = document.querySelector('.tower-cell[data-floor="' + floor + '"][data-col="' + t + '"]');
      if (tc && !tc.classList.contains('revealed')) { tc.classList.add('revealed', 'shown'); tc.textContent = '\u2620'; }
    });
    showResult('tower-result', false, 'Trapped on floor ' + (floor + 1) + '! Lost ' + towerState.bet.toLocaleString() + ' SPUNK\u2022BET');
    addHistory('Rune Tower', towerState.bet, 'lose', -towerState.bet, towerState.seedData);
    document.getElementById('tower-cashout-btn').style.display = 'none';
    document.getElementById('tower-start-btn').style.display = '';
  } else {
    cell.classList.add('revealed', 'safe');
    cell.textContent = '\u2B50';
    // Reveal traps on this floor
    towerState.traps[floor].forEach(t => {
      const tc = document.querySelector('.tower-cell[data-floor="' + floor + '"][data-col="' + t + '"]');
      if (tc && !tc.classList.contains('revealed')) { tc.classList.add('revealed', 'shown'); tc.textContent = '\u2620'; }
    });
    towerState.currentFloor++;
    const multi = getTowerMulti(towerState.currentFloor, towerState.diff);
    const profit = Math.floor(towerState.bet * multi) - towerState.bet;
    document.getElementById('tower-floor').textContent = towerState.currentFloor;
    document.getElementById('tower-multi').textContent = multi.toFixed(2) + 'x';
    document.getElementById('tower-profit').textContent = '+' + profit.toLocaleString();
    if (towerState.currentFloor >= towerState.config.floors) {
      cashoutTower();
    } else {
      // Unlock next floor
      document.querySelectorAll('.tower-cell[data-floor="' + towerState.currentFloor + '"]').forEach(c => {
        c.classList.remove('locked');
        c.classList.add('current');
        c.onclick = () => climbTower(parseInt(c.dataset.floor), parseInt(c.dataset.col));
      });
    }
  }
}
function cashoutTower() {
  if (!towerState || !towerState.active) return;
  towerState.active = false;
  const multi = getTowerMulti(towerState.currentFloor, towerState.diff);
  const payout = Math.floor(towerState.bet * multi);
  balance += payout;
  const profit = payout - towerState.bet;
  showResult('tower-result', true, 'Escaped at floor ' + towerState.currentFloor + ' (' + multi.toFixed(2) + 'x)! Won +' + profit.toLocaleString() + ' SPUNK\u2022BET');
  addHistory('Rune Tower', towerState.bet, 'win', profit, towerState.seedData);
  document.getElementById('tower-cashout-btn').style.display = 'none';
  document.getElementById('tower-start-btn').style.display = '';
  updateBalance(); saveState();
}

// ===== XVERSE WALLET =====
let walletState = { connected: false, paymentAddress: null, ordinalsAddress: null };

function handleWalletClick() {
  if (walletState.connected) {
    showWalletDetails();
  } else {
    document.getElementById('wallet-modal').classList.add('show');
    document.getElementById('wallet-install-hint').style.display = 'none';
    document.getElementById('wallet-install-text').innerHTML = '';
  }
}

function closeWalletModal() { document.getElementById('wallet-modal').classList.remove('show'); }
function closeWalletDetails() { document.getElementById('wallet-details-modal').classList.remove('show'); }

function showWalletDetails() {
  const el = document.getElementById('wallet-info-details');
  const shortAddr = (a) => a ? a.slice(0, 8) + '...' + a.slice(-6) : 'N/A';
  el.innerHTML =
    '<div class="wallet-info-row"><span class="wallet-info-label">Payment</span><span class="wallet-info-value">' + shortAddr(walletState.paymentAddress) + '</span></div>' +
    '<div class="wallet-info-row"><span class="wallet-info-label">Ordinals</span><span class="wallet-info-value">' + shortAddr(walletState.ordinalsAddress) + '</span></div>' +
    '<div class="wallet-info-row"><span class="wallet-info-label">Network</span><span class="wallet-info-value">Mainnet</span></div>';

  const count = getReferralCount();
  const tier = getTier(count);
  document.getElementById('wallet-tier-display').innerHTML =
    '<div style="display:flex;justify-content:space-between;align-items:center;font-size:0.85rem;">' +
      '<span style="color:var(--muted);">Referral Tier</span>' +
      '<span class="tier-badge ' + tier.css + '">' + tier.name + '</span>' +
    '</div>' +
    '<div style="display:flex;justify-content:space-between;align-items:center;font-size:0.85rem;margin-top:0.3rem;">' +
      '<span style="color:var(--muted);">Referrals</span>' +
      '<span style="font-weight:700;color:var(--accent);">' + count + '</span>' +
    '</div>';
  document.getElementById('wallet-details-modal').classList.add('show');
}

function updateWalletButton() {
  const btn = document.getElementById('wallet-btn');
  if (walletState.connected) {
    const short = walletState.paymentAddress.slice(0, 6) + '...' + walletState.paymentAddress.slice(-4);
    btn.className = 'wallet-btn connected';
    btn.innerHTML = '<div class="wallet-dot"></div>' + short;
  } else {
    btn.className = 'wallet-btn';
    btn.textContent = 'Connect Wallet';
  }
}

function updateShareButton() {
  document.getElementById('share-btn').classList.toggle('visible', walletState.connected);
  const mobileShare = document.getElementById('mobile-share-btn');
  if (mobileShare) mobileShare.style.display = walletState.connected ? '' : 'none';
}

function disconnectWallet() {
  walletState = { connected: false, paymentAddress: null, ordinalsAddress: null };
  localStorage.removeItem('spunkbet_wallet');
  updateWalletButton();
  updateShareButton();
  closeWalletDetails();
}

function onWalletConnected() {
  updateWalletButton();
  updateShareButton();
  closeWalletModal();
  saveState();
  processReferralOnConnect(walletState.paymentAddress);
}

function getXverseProvider() {
  if (window.XverseProviders?.BitcoinProvider) return window.XverseProviders.BitcoinProvider;
  if (window.BitcoinProvider) return window.BitcoinProvider;
  if (window.btc_providers) {
    const xverse = window.btc_providers.find(p =>
      p.id === 'BitcoinProvider' || p.id === 'xverseProviders.BitcoinProvider'
    );
    if (xverse) return xverse.id.split('.').reduce((obj, key) => obj?.[key], window);
  }
  return null;
}

async function connectXverse() {
  const provider = getXverseProvider();
  if (!provider) { document.getElementById('wallet-install-hint').style.display = 'block'; return; }
  try {
    const connectResponse = await provider.request('wallet_connect', {
      addresses: ['payment', 'ordinals'],
      message: 'Spunk.bet wants to connect your wallet',
      network: 'Mainnet'
    });
    if (connectResponse.status === 'success') {
      const addresses = connectResponse.result.addresses || [];
      const payment = addresses.find(a => a.purpose === 'payment');
      const ordinals = addresses.find(a => a.purpose === 'ordinals');
      if (payment || addresses.length > 0) {
        walletState = { connected: true, paymentAddress: payment?.address || addresses[0]?.address, ordinalsAddress: ordinals?.address || null, provider: 'xverse' };
        onWalletConnected();
        return;
      }
    }
    const addrResponse = await provider.request('getAddresses', { purposes: ['payment', 'ordinals'] });
    if (addrResponse.status === 'success') {
      const addresses = addrResponse.result.addresses || addrResponse.result || [];
      const payment = addresses.find(a => a.purpose === 'payment');
      const ordinals = addresses.find(a => a.purpose === 'ordinals');
      walletState = { connected: true, paymentAddress: payment?.address || addresses[0]?.address, ordinalsAddress: ordinals?.address || null, provider: 'xverse' };
      onWalletConnected();
    }
  } catch (err) {
    if (err?.error?.code === -32000 || err?.code === 4001 || err?.error?.code === 4001) {
      closeWalletModal();
    } else {
      console.error('Xverse connection error:', err);
      document.getElementById('wallet-install-hint').style.display = 'block';
    }
  }
}

// ===== UNISAT WALLET =====
async function connectUnisat() {
  if (!window.unisat) {
    const hint = document.getElementById('wallet-install-hint');
    document.getElementById('wallet-install-text').innerHTML = 'Unisat not detected. <a href="https://unisat.io/download" target="_blank" style="color:var(--accent); text-decoration:none; font-weight:600;">Download Unisat</a> and refresh.';
    hint.style.display = 'block';
    return;
  }
  try {
    const accounts = await window.unisat.requestAccounts();
    if (accounts && accounts.length > 0) {
      walletState = {
        connected: true,
        paymentAddress: accounts[0],
        ordinalsAddress: accounts[0],
        provider: 'unisat'
      };
      onWalletConnected();
    }
  } catch (err) {
    if (err?.code === 4001) {
      closeWalletModal();
    } else {
      console.error('Unisat connection error:', err);
    }
  }
}

// ===== MAGIC EDEN WALLET =====
async function connectMagicEden() {
  const provider = window.magicEden?.bitcoin || window.MagicEden?.bitcoin;
  if (!provider) {
    const hint = document.getElementById('wallet-install-hint');
    document.getElementById('wallet-install-text').innerHTML = 'Magic Eden wallet not detected. <a href="https://wallet.magiceden.io/" target="_blank" style="color:var(--accent); text-decoration:none; font-weight:600;">Download Magic Eden Wallet</a> and refresh.';
    hint.style.display = 'block';
    return;
  }
  try {
    const accounts = await provider.connect();
    if (accounts && accounts.length > 0) {
      const payment = accounts.find(a => a.purpose === 'payment');
      const ordinals = accounts.find(a => a.purpose === 'ordinals');
      walletState = {
        connected: true,
        paymentAddress: payment?.address || accounts[0]?.address || accounts[0],
        ordinalsAddress: ordinals?.address || accounts[0]?.address || accounts[0],
        provider: 'magiceden'
      };
      onWalletConnected();
    }
  } catch (err) {
    if (err?.code === 4001) {
      closeWalletModal();
    } else {
      console.error('Magic Eden connection error:', err);
      // Try alternative API
      try {
        const res = await provider.requestAccounts();
        if (res && res.length > 0) {
          walletState = {
            connected: true,
            paymentAddress: res[0],
            ordinalsAddress: res[0],
            provider: 'magiceden'
          };
          onWalletConnected();
        }
      } catch (e2) {
        console.error('Magic Eden fallback error:', e2);
      }
    }
  }
}

// ===== PAYOUT API =====
const API_BASE = 'https://spunkbet-api.vercel.app';

async function claimFaucetOnChain() {
  if (!walletState.connected) return;
  try {
    const res = await fetch(API_BASE + '/api/claim', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ type: 'faucet', address: walletState.paymentAddress })
    });
    const data = await res.json();
    if (data.success) {
      showToast('Runes sent! TX: <span class="toast-amount">' + data.txid.slice(0, 12) + '...</span>');
    } else if (data.error) {
      showToast(data.error);
    }
  } catch (err) {
    console.error('Faucet claim error:', err);
  }
}

async function claimReferralOnChain(referrerAddress) {
  if (!walletState.connected) return;
  try {
    const res = await fetch(API_BASE + '/api/claim', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type: 'referral',
        address: referrerAddress,
        referrerCode: walletState.paymentAddress.slice(0, 8),
        referredAddress: walletState.paymentAddress
      })
    });
    const data = await res.json();
    if (data.success) {
      showToast('Referral reward sent on-chain! TX: <span class="toast-amount">' + data.txid.slice(0, 12) + '...</span>');
    }
  } catch (err) {
    console.error('Referral claim error:', err);
  }
}

// ===== REFERRAL MODAL =====
function openReferralModal() {
  if (!walletState.connected) return;
  const code = walletState.paymentAddress.slice(0, 8);
  const link = window.location.origin + window.location.pathname + '?ref=' + code;
  document.getElementById('referral-link-input').value = link;
  document.getElementById('referral-code').textContent = code;
  const count = getReferralCount();
  document.getElementById('referral-count').textContent = count;
  const tier = getTier(count);
  document.getElementById('referral-tier').innerHTML = '<span class="tier-badge ' + tier.css + '">' + tier.name + '</span>';
  document.getElementById('referral-earned').textContent = getReferralEarnings().toLocaleString();
  renderTierCards('tiers-grid', count);
  document.getElementById('referral-modal').classList.add('show');
}

function closeReferralModal() { document.getElementById('referral-modal').classList.remove('show'); }

function shareReferralOnX() {
  if (!walletState.connected) return;
  const code = walletState.paymentAddress.slice(0, 8);
  const link = 'https://spunk.bet?ref=' + code;
  const text = 'Free crypto casino on Bitcoin \uD83C\uDFB0\n\nNo KYC, provably fair. Claim 10k free tokens \u2192 ' + link;
  const url = 'https://x.com/intent/tweet?text=' + encodeURIComponent(text);
  window.open(url, '_blank', 'width=550,height=420');
}

function shareFirst100() {
  if (!walletState.connected) {
    document.getElementById('wallet-modal').classList.add('show');
    document.getElementById('wallet-install-hint').style.display = 'none';
    document.getElementById('wallet-install-text').innerHTML = '';
    showToast('Connect wallet first to get your referral link');
    return;
  }
  const code = walletState.paymentAddress.slice(0, 8);
  const link = 'https://spunk.bet?ref=' + code;
  const remaining = document.getElementById('first100-count')?.textContent || '?';
  const text = 'Only ' + remaining + ' spots left for 2x bonus rewards on Spunk.Bet \uD83C\uDFB0\n\nFree Bitcoin casino, no KYC. Claim yours \u2192 ' + link;
  const url = 'https://x.com/intent/tweet?text=' + encodeURIComponent(text);
  window.open(url, '_blank', 'width=550,height=420');
}

function copyReferralLink() {
  const input = document.getElementById('referral-link-input');
  navigator.clipboard.writeText(input.value).then(() => {
    const btn = input.nextElementSibling;
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
  });
}

// ===== WALLET ADDRESS COPY =====
function copyWalletAddr(id) {
  const input = document.getElementById(id);
  navigator.clipboard.writeText(input.value).then(() => {
    const btn = input.nextElementSibling;
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
  });
}

// Close modals on backdrop click
document.getElementById('wallet-modal').addEventListener('click', (e) => { if (e.target === e.currentTarget) closeWalletModal(); });
document.getElementById('wallet-details-modal').addEventListener('click', (e) => { if (e.target === e.currentTarget) closeWalletDetails(); });
document.getElementById('referral-modal').addEventListener('click', (e) => { if (e.target === e.currentTarget) closeReferralModal(); });

// Update faucet timer every minute
setInterval(updateFaucetButton, 60000);

// ===== TURBO MODE =====
let turboMode = {};
function toggleTurbo(game) {
  const cb = document.getElementById('turbo-' + game);
  turboMode[game] = cb ? cb.checked : false;
}
function isTurbo(game) { return !!turboMode[game]; }

// ===== AUTOBET ENGINE =====
const autobetState = {};
const AUTOBET_GAMES = ['coinflip','dice','mines','crash','limbo','keno','wheel','plinko','hilo','tower'];

function getAutobetPanelHTML(game) {
  return '<div class="autobet-row"><span class="autobet-label">Number of Bets</span><input type="number" class="autobet-input" id="ab-count-'+game+'" value="0" min="0" placeholder="0 = infinite"></div>' +
    '<div class="autobet-row"><span class="autobet-label">On Win</span><select class="autobet-select" id="ab-onwin-'+game+'"><option value="reset">Reset</option><option value="increase">Increase by %</option></select><input type="number" class="autobet-input" id="ab-onwin-pct-'+game+'" value="0" min="0" style="max-width:60px;display:none;" placeholder="%"></div>' +
    '<div class="autobet-row"><span class="autobet-label">On Loss</span><select class="autobet-select" id="ab-onloss-'+game+'"><option value="reset">Reset</option><option value="increase">Increase by %</option></select><input type="number" class="autobet-input" id="ab-onloss-pct-'+game+'" value="0" min="0" style="max-width:60px;display:none;" placeholder="%"></div>' +
    '<div class="autobet-row"><span class="autobet-label">Stop on Profit</span><input type="number" class="autobet-input" id="ab-stopprofit-'+game+'" value="0" min="0" placeholder="0 = no limit"></div>' +
    '<div class="autobet-row"><span class="autobet-label">Stop on Loss</span><input type="number" class="autobet-input" id="ab-stoploss-'+game+'" value="0" min="0" placeholder="0 = no limit"></div>' +
    '<button class="autobet-btn start" id="ab-btn-'+game+'" onclick="toggleAutobet(\''+game+'\')">Start Autobet</button>';
}

function initAutobetPanels() {
  AUTOBET_GAMES.forEach(game => {
    const panel = document.getElementById('autobet-' + game);
    if (panel) {
      panel.innerHTML = getAutobetPanelHTML(game);
      autobetState[game] = { running: false, count: 0, baseBet: 0, totalProfit: 0, totalLoss: 0 };
    }
    // Toggle % input visibility
    const onwinSel = document.getElementById('ab-onwin-' + game);
    const onlossSel = document.getElementById('ab-onloss-' + game);
    if (onwinSel) onwinSel.onchange = function() { document.getElementById('ab-onwin-pct-' + game).style.display = this.value === 'increase' ? '' : 'none'; };
    if (onlossSel) onlossSel.onchange = function() { document.getElementById('ab-onloss-pct-' + game).style.display = this.value === 'increase' ? '' : 'none'; };
  });
}

function setAutoMode(game, isAuto, tabEl) {
  const tabs = tabEl.parentElement.querySelectorAll('.mode-tab');
  tabs.forEach(t => t.classList.remove('active'));
  tabEl.classList.add('active');
  const panel = document.getElementById('autobet-' + game);
  if (panel) panel.classList.toggle('show', isAuto);
}

function toggleAutobet(game) {
  const state = autobetState[game];
  if (state.running) {
    stopAutobet(game);
  } else {
    startAutobet(game);
  }
}

function startAutobet(game) {
  const state = autobetState[game];
  const betInputMap = { coinflip:'cf-bet', dice:'dice-bet', mines:'mines-bet', crash:'crash-bet', limbo:'limbo-bet', keno:'keno-bet', wheel:'wheel-bet', plinko:'plinko-bet', hilo:'hilo-bet', tower:'tower-bet' };
  const betInput = document.getElementById(betInputMap[game]);
  state.baseBet = parseInt(betInput.value) || 100;
  state.running = true;
  state.count = 0;
  state.totalProfit = 0;
  state.totalLoss = 0;
  const btn = document.getElementById('ab-btn-' + game);
  btn.textContent = 'Stop Autobet';
  btn.className = 'autobet-btn stop';
  runAutobetRound(game);
}

function stopAutobet(game) {
  const state = autobetState[game];
  state.running = false;
  const btn = document.getElementById('ab-btn-' + game);
  btn.textContent = 'Start Autobet';
  btn.className = 'autobet-btn start';
}

function getAutobetSettings(game) {
  return {
    maxBets: parseInt(document.getElementById('ab-count-' + game).value) || 0,
    onWin: document.getElementById('ab-onwin-' + game).value,
    onWinPct: parseFloat(document.getElementById('ab-onwin-pct-' + game).value) || 0,
    onLoss: document.getElementById('ab-onloss-' + game).value,
    onLossPct: parseFloat(document.getElementById('ab-onloss-pct-' + game).value) || 0,
    stopProfit: parseInt(document.getElementById('ab-stopprofit-' + game).value) || 0,
    stopLoss: parseInt(document.getElementById('ab-stoploss-' + game).value) || 0
  };
}

function adjustAutobetBet(game, won) {
  const betInputMap = { coinflip:'cf-bet', dice:'dice-bet', mines:'mines-bet', crash:'crash-bet', limbo:'limbo-bet', keno:'keno-bet', wheel:'wheel-bet', plinko:'plinko-bet', hilo:'hilo-bet', tower:'tower-bet' };
  const state = autobetState[game];
  const settings = getAutobetSettings(game);
  const betInput = document.getElementById(betInputMap[game]);
  let currentBet = parseInt(betInput.value) || state.baseBet;
  if (won) {
    if (settings.onWin === 'reset') currentBet = state.baseBet;
    else currentBet = Math.floor(currentBet * (1 + settings.onWinPct / 100));
  } else {
    if (settings.onLoss === 'reset') currentBet = state.baseBet;
    else currentBet = Math.floor(currentBet * (1 + settings.onLossPct / 100));
  }
  currentBet = Math.max(MIN_BET, currentBet);
  betInput.value = currentBet;
}

function checkAutobetStop(game, won, profitThisRound) {
  const state = autobetState[game];
  const settings = getAutobetSettings(game);
  if (won) state.totalProfit += profitThisRound;
  else state.totalLoss += Math.abs(profitThisRound);
  state.count++;
  if (settings.maxBets > 0 && state.count >= settings.maxBets) { stopAutobet(game); return true; }
  if (settings.stopProfit > 0 && state.totalProfit >= settings.stopProfit) { stopAutobet(game); return true; }
  if (settings.stopLoss > 0 && state.totalLoss >= settings.stopLoss) { stopAutobet(game); return true; }
  if (balance < MIN_BET) { stopAutobet(game); return true; }
  return false;
}

async function runAutobetRound(game) {
  if (!autobetState[game].running) return;
  const balanceBefore = balance;

  // Call the game's play function
  const playFnMap = {
    coinflip: () => flipCoin(),
    dice: () => rollDice(),
    mines: () => autoplayMines(),
    crash: () => autoplayCrash(),
    limbo: () => playLimbo(),
    keno: () => playKenoAnimated(),
    wheel: () => spinWheel(),
    plinko: () => dropPlinko(),
    hilo: () => autoplayHiLo(),
    tower: () => autoplayTower()
  };

  try {
    await playFnMap[game]();
  } catch(e) {
    console.error('Autobet error:', e);
    stopAutobet(game);
    return;
  }

  // Wait for game animations to finish
  const delayMap = { coinflip:900, dice:700, mines:800, crash:2000, limbo:650, keno:2200, wheel:4500, plinko:2500, hilo:1200, tower:800 };
  const turboDelayMap = { coinflip:200, dice:200, mines:400, crash:1000, limbo:200, keno:500, wheel:1500, plinko:800, hilo:600, tower:400 };
  const delay = isTurbo(game) ? (turboDelayMap[game] || 300) : (delayMap[game] || 1000);

  setTimeout(() => {
    if (!autobetState[game].running) return;
    const profitThisRound = balance - balanceBefore;
    const won = profitThisRound > 0;
    adjustAutobetBet(game, won);
    if (!checkAutobetStop(game, won, profitThisRound)) {
      runAutobetRound(game);
    }
  }, delay);
}

// Auto-play helpers for multi-step games
async function autoplayMines() {
  await startMines();
  // Auto-reveal 3 random safe-looking tiles then cashout
  await new Promise(r => setTimeout(r, 300));
  if (minesState && minesState.active) {
    const unrevealed = [];
    document.querySelectorAll('.mine-cell').forEach((c, i) => { if (!c.classList.contains('revealed')) unrevealed.push(i); });
    // Reveal 1-3 random tiles then cashout
    const reveals = Math.min(3, unrevealed.length);
    for (let i = 0; i < reveals; i++) {
      if (!minesState || !minesState.active) break;
      const idx = Math.floor(Math.random() * unrevealed.length);
      revealMine(unrevealed[idx]);
      unrevealed.splice(idx, 1);
      await new Promise(r => setTimeout(r, 150));
    }
    if (minesState && minesState.active) cashoutMines();
  }
}

async function autoplayCrash() {
  await startCrash();
  // Auto cashout at 2x
  return new Promise(resolve => {
    const check = setInterval(() => {
      if (!crashState) { clearInterval(check); resolve(); return; }
      if (crashState.multi >= 2.0 && crashState.active && !crashState.cashed) {
        cashoutCrash();
        clearInterval(check);
        resolve();
      }
      if (!crashState.active) { clearInterval(check); resolve(); }
    }, 50);
  });
}

async function autoplayHiLo() {
  await startHiLo();
  await new Promise(r => setTimeout(r, 400));
  // Always pick higher, then cashout after 1 correct
  if (hiloState && hiloState.active) {
    guessHiLo('hi');
    await new Promise(r => setTimeout(r, 800));
    if (hiloState && hiloState.active) cashoutHiLo();
  }
}

async function autoplayTower() {
  await startTower();
  await new Promise(r => setTimeout(r, 300));
  // Click first cell of floor 0, then cashout
  if (towerState && towerState.active) {
    climbTower(0, 0);
    await new Promise(r => setTimeout(r, 300));
    if (towerState && towerState.active) cashoutTower();
  }
}

// ===== LIMBO HISTORY =====
let limboHistory = [];

function addLimboHistory(result, target) {
  const win = result >= target;
  limboHistory.unshift({ result, win });
  if (limboHistory.length > 25) limboHistory.pop();
  renderLimboHistory();
}

function renderLimboHistory() {
  const container = document.getElementById('limbo-history');
  if (!container) return;
  container.innerHTML = limboHistory.map(h =>
    '<div class="limbo-history-item ' + (h.win ? 'win' : 'lose') + '">' + h.result.toFixed(2) + 'x</div>'
  ).join('');
  // Scroll to show newest (leftmost)
  container.scrollLeft = 0;
}

// ===== KENO ANIMATED DRAW =====
async function playKenoAnimated() {
  if (kenoSelected.size === 0) { showToast('Pick at least 1 number'); return; }
  const bet = getBet('keno-bet');
  if (bet <= 0 || bet > balance) return;
  balance -= bet;
  updateBalance();

  // Clear drawn area
  const drawnArea = document.getElementById('keno-drawn-area');
  if (drawnArea) drawnArea.innerHTML = '';

  const seedBefore = { serverSeedHash: pfState.serverSeedHash, clientSeed: pfState.clientSeed, nonce: pfState.nonce };
  const drawn = [];
  const avail = Array.from({length: 40}, (_, i) => i + 1);
  for (let i = 0; i < 10; i++) {
    const rand = await fairRandom();
    const idx = Math.floor(rand * avail.length);
    drawn.push(avail[idx]);
    avail.splice(idx, 1);
  }
  const seedAfter = { ...seedBefore, serverSeed: pfState.serverSeed };
  await rotateServerSeed(); savePFState();

  const cells = document.querySelectorAll('.keno-cell');
  const picks = kenoSelected.size;

  // Per-ball win calculation
  let hits = 0;
  const revealBall = (i) => {
    return new Promise(resolve => {
      setTimeout(() => {
        const num = drawn[i];
        const isHit = kenoSelected.has(num);
        if (isHit) hits++;

        // Mark on grid with highlight
        const cell = cells[num - 1];
        cell.classList.add('drawn');
        if (isHit) {
          cell.classList.add('hit');
          cell.textContent = '\u2713';
        } else {
          cell.classList.add('miss');
        }

        // Add ball to drawn area
        if (drawnArea) {
          const ball = document.createElement('div');
          ball.className = 'keno-ball ' + (isHit ? 'hit' : 'miss');
          ball.textContent = num;
          if (isHit) {
            const perBallMulti = getKenoMultiplier(picks, hits);
            if (perBallMulti > 0) {
              const winSpan = document.createElement('span');
              winSpan.className = 'ball-win';
              winSpan.textContent = '+' + Math.floor(bet * perBallMulti).toLocaleString();
              ball.appendChild(winSpan);
            }
          }
          drawnArea.appendChild(ball);
        }
        resolve();
      }, i * 180);
    });
  };

  // Stagger reveal all balls
  const promises = [];
  for (let i = 0; i < 10; i++) {
    promises.push(revealBall(i));
  }
  await Promise.all(promises);

  // Wait for last ball animation
  await new Promise(r => setTimeout(r, 200));

  // Mark selected but not drawn cells
  cells.forEach((cell, idx) => {
    const num = idx + 1;
    if (kenoSelected.has(num) && !drawn.includes(num)) {
      cell.classList.add('drawn', 'selected', 'miss');
    }
  });

  const multi = getKenoMultiplier(picks, hits);
  showGameSeed('keno-seed', seedAfter.serverSeed, seedAfter.serverSeedHash);
  if (multi > 0) {
    const payout = Math.floor(bet * multi);
    balance += payout;
    showResult('keno-result', true, hits + ' hits! ' + multi + 'x payout. Won +' + (payout - bet).toLocaleString() + ' SPUNK\u2022BET');
    addHistory('Keno', bet, 'win', payout - bet, seedAfter);
  } else {
    showResult('keno-result', false, hits + ' hits. Not enough to win. Lost ' + bet.toLocaleString() + ' SPUNK\u2022BET');
    addHistory('Keno', bet, 'lose', -bet, seedAfter);
  }
  updateBalance(); saveState();
}

// ===== INIT =====
captureReferral();
loadState();
updateDiceSlider();
initProvablyFair();
initAutobetPanels();
</script>
</body>
</html>
